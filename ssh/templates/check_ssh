#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Locate awk
AWK=$(command -v awk 2>/dev/null)
[ -n "$AWK" ] || die "awk not available"

# Locate date
DATE=$(command -v date 2>/dev/null)
[ -n "$DATE" ] || die "date not available"

# Locate ps
PS=$(command -v ps 2>/dev/null)
[ -n "$PS" ] || die "ps not available"

# Locate printf
PRINTF=$(command -v printf 2>/dev/null)
[ -n "$PRINTF" ] || die "printf not available"

# Locate sed
SED=$(command -v sed 2>/dev/null)
[ -n "$SED" ] || die "sed not available"

<% if @systemd_enable -%>
# Locate systemctl
SYSTEMDCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMDCTL" ] || die "systemctl not available"

# Locate journalctl
JOURNALCTL$(command -v journalctl 2>/dev/null)
[ -n "$JOURNALCTL" ] || die "journalctl not available"

<% end -%>
# Locate wc
WC=$(command -v wc 2>/dev/null)
[ -n "$WC" ] || die "wc not available"

# Locate who
WHO=$(command -v who 2>/dev/null)
[ -n "$WHO" ] || die "who not available"

crit() {
    $PRINTF '%s\n' "$*" >&2
    exit 2
}

# Default thresholds
ALLOWED_USERS="<%= @check_users_str %>"
CRIT_THRESH=2      # critical session count (active)
WARN_THRESH=1      # warning session count (active)
TIMEFRAME=10       # minutes to look back for auth failures
MAX_IDLE=5         # minutes: session idle-time ≤ MAX_IDLE ⇒ active
MAX_AGE=30         # minutes: session age   >  MAX_AGE  ⇒ CRITICAL
STATE_CODE=0

# Parse options
while getopts 'c:w:t:i:a:' opt; do
    case "$opt" in
        c) CRIT_THRESH="$OPTARG" ;;
        w) WARN_THRESH="$OPTARG" ;;
        t) TIMEFRAME="$OPTARG" ;;
        i) MAX_IDLE="$OPTARG" ;;
        a) MAX_AGE="$OPTARG" ;;
        *) die "Usage: $0 [-c <crit>] [-w <warn>] [-t <fail-minutes>] [-i <max-idle>] [-a <max-age>]" ;;
    esac
done

# Service check
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "<%= @service %>" || crit "SSH service is not active"
<% else -%>
$PS -C sshd >/dev/null 2>&1 || crit "SSH service is not active"
<% end -%>

# Analyse current SSH sessions
ACTIVE_SESSIONS=0
AGE_CRIT=false
NOW_EPOCH=$($DATE +%s)
ROOT_LOGIN=false
SEP=""
USERS_LIST=""
WHO_OUTPUT=$($WHO -u)

# Count zombie sshd processes
ZOMBIE_COUNT=$($PS -C sshd -o stat= | $AWK '$0 ~ /Z/ {c++} END {print c+0}')

while read -r USER TTY LOGIN_DATE LOGIN_TIME IDLE _; do
    # Skip users
    if [ -z "$USER" ] || [ ! -e "/dev/$TTY" ]; then
        continue
    fi

    # Check root login
    [ "$USER" = "root" ] && ROOT_LOGIN=true

    # Add user to list
    case ",$USERS_LIST," in
        *,"$USER",*) ;;
        *) USERS_LIST="${USERS_LIST}${SEP}${USER}"; SEP="," ;;
    esac

    # Determine idle minutes
    case "$IDLE" in
        '.')    IDLE_MIN=0 ;;
        'old')  IDLE_MIN=$((MAX_IDLE + 1)) ;;
        *:* )   H=${IDLE%%:*}; M=${IDLE##*:}; H=${H#0}; M=${M#0}; [ -z "$H" ] && H=0; [ -z "$M" ] && M=0; IDLE_MIN=$((H*60 + M)) ;;
        *d)     D=${IDLE%%[^0-9]*}; IDLE_MIN=$((D*1440)) ;;
        *)      IDLE_MIN=$((MAX_IDLE + 1)) ;;
    esac

    # PS call
    TTY_PROCS=$($PS -t "$TTY" -o user=)
    PROC_COUNT=$($PRINTF '%s\n' "$TTY_PROCS" | $WC -l)

    case "$TTY_PROCS" in
        *root*) ROOT_LOGIN=true ;;
    esac

    # Count sessions
    if [ "$PROC_COUNT" -ge 1 ] || [ "$IDLE_MIN" -le "$MAX_IDLE" ]; then
        ACTIVE_SESSIONS=$((ACTIVE_SESSIONS + 1))
    fi

    # Age check
    LOGIN_EPOCH=$($DATE -d "$LOGIN_DATE $LOGIN_TIME" +%s 2>/dev/null) || LOGIN_EPOCH=0
    if [ "$LOGIN_EPOCH" -ne 0 ]; then
        AGE_MIN=$(((NOW_EPOCH - LOGIN_EPOCH)/60))
        [ "$AGE_MIN" -gt "$MAX_AGE" ] && AGE_CRIT=true
    fi
done <<EOF
$WHO_OUTPUT
EOF

# Auth failure detection
<% if @systemd_enable -%>
PAT='Failed password|Failed publickey|Invalid user|authentication failure|kex_exchange_identification|userauth_pubkey'
OUT=$($JOURNALCTL -q -o short-unix -u ssh -u sshd --since today | AWK -v allow="$ALLOWED_USERS" -v pat="$PAT" '
BEGIN{
    split(allow,a,","); for(i in a) w[a[i]]=1
    f=0; sep=""; bad=""
}
{
    msg=substr($0,index($0,": ")+2)
    if(msg~pat) f++

    u=""
    if(msg~/Invalid user/){
        match(msg,/Invalid user[[:space:]]+([[:alnum:]_.-]+)/,m); u=m[1]
    } else if(msg~/Failed publickey for/){
        match(msg,/Failed publickey for[[:space:]]+([[:alnum:]_.-]+)/,m); u=m[1]
    }

    if(u!="" && !(u in w)){
        if(!(u in seen)){
            bad=bad sep u; sep=","
            seen[u]=1
        }
    }
}
END{print f ":" bad}')
FAIL_COUNT=${OUT%%:*}
BAD=${OUT#*:}
<% else -%>
FAIL_COUNT=0
BAD=""
<% end -%>

# Determine state
if [ "$ROOT_LOGIN" = true ] || [ "$AGE_CRIT" = true ]; then
    STATE_CODE=2
elif [ "$ACTIVE" -ge "$CRIT_THRESH" ]; then
    STATE_CODE=2
elif [ "$ACTIVE" -ge "$WARN_THRESH" ]; then
    STATE_CODE=1
fi
if [ "$STATE_CODE" -lt 1 ]; then
    if [ "$ZOMBIE_COUNT" -gt 0 ]; then
        STATE=1
    elif [ -n "$BAD" ]; then
        STATE=1
    fi
fi

# Create message
EXTRA=""
[ "$ROOT_LOGIN" = true ] && EXTRA="${EXTRA}root login, "
[ "$AGE_CRIT" = true ] && EXTRA="${EXTRA}age> ${MAX_AGE}m, "
[ -n "$BAD" ] && EXTRA="${EXTRA}invalid login attempt by '$BAD', "
[ "$ZOMBIE_COUNT" -gt 0 ] && EXTRA="${EXTRA}${ZOMBIE_COUNT} zombies, "
[ "$FAIL_COUNT" -gt 0 ] && EXTRA="${EXTRA}${FAIL_COUNT} auth fails, "
[ -n "$USERS_LIST" ] && EXTRA="${EXTRA}users=$USERS_LIST, "
EXTRA=$(echo "$EXTRA" | $SED 's/, $//')
[ -n "$EXTRA" ] && EXTRA=" ($EXTRA)"

# Create perfdata
PERF_DATA="sessions=${ACTIVE_SESSIONS};${WARN_THRESH};${CRIT_THRESH};0;"
PERF_DATA="$PERF_DATA zombies=${ZOMBIE_COUNT};;;;"
PERF_DATA="$PERF_DATA fails=${FAIL_COUNT};;;;"
PERF_DATA="$PERF_DATA age_crit=$([ "$AGE_CRIT" = true ] && echo 1 || echo 0);;;;"

# Output
$PRINTF '%s active SSH session(s)%s | %s\n' "$ACTIVE_SESSIONS" "$EXTRA" "$PERF_DATA"
exit "$STATE_CODE"
