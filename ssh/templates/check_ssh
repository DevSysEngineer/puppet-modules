#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Binary checks
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
DATE=$(command -v date 2>/dev/null) || die "date not available"
PS=$(command -v ps 2>/dev/null) || die "ps not available"
SED=$(command -v sed 2>/dev/null) || die "sed not available"
<% if @systemd_enable -%>
SYSTEMDCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
JOURNALCTL=$(command -v journalctl 2>/dev/null) || die "journalctl not available"
<% end -%>
WC=$(command -v wc 2>/dev/null) || die "wc not available"
WHO=$(command -v who 2>/dev/null) || die "who not available"

crit() {
    printf '%s\n' "$*" >&2
    exit 2
}

# Default thresholds
ALLOWED_USERS="<%= @check_users_str %>"
CRIT_THRESH=2      # critical session count (active)
WARN_THRESH=1      # warning session count (active)
TIMEFRAME=10       # minutes to look back for auth failures
MAX_IDLE=5         # minutes: session idle-time ≤ MAX_IDLE ⇒ active
MAX_AGE=30         # minutes: session age   >  MAX_AGE  ⇒ CRITICAL
STATE_CODE=0

# Parse options
while getopts 'c:w:t:i:a:' opt; do
    case "$opt" in
        c) CRIT_THRESH="$OPTARG" ;;
        w) WARN_THRESH="$OPTARG" ;;
        t) TIMEFRAME="$OPTARG" ;;
        i) MAX_IDLE="$OPTARG" ;;
        a) MAX_AGE="$OPTARG" ;;
        *) die "Usage: $0 [-c <crit>] [-w <warn>] [-t <fail-minutes>] [-i <max-idle>] [-a <max-age>]" ;;
    esac
done

# Service check
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "<%= @service %>" || crit "SSH service is not active"
<% else -%>
$PS -C sshd >/dev/null 2>&1 || crit "SSH service is not active"
<% end -%>

# Analyse current SSH sessions
ACTIVE_SESSIONS=0
AGE_CRIT=false
NOW_EPOCH=$($DATE +%s)
ROOT_LOGIN=false
SEP=""
USERS_LIST=""
WHO_OUTPUT=$($WHO -u)

# Count zombie sshd processes
ZOMBIE_COUNT=$($PS -C sshd -o stat= | $AWK '$0 ~ /Z/ {c++} END {print c+0}')

while read -r USER TTY LOGIN_DATE LOGIN_TIME IDLE _; do
    # Skip users
    if [ -z "$USER" ] || [ ! -e "/dev/$TTY" ]; then
        continue
    fi

    # Check root login
    [ "$USER" = "root" ] && ROOT_LOGIN=true

    # Add user to list
    case ",$USERS_LIST," in
        *,"$USER",*) ;;
        *) USERS_LIST="${USERS_LIST}${SEP}${USER}"; SEP="," ;;
    esac

    # Determine idle minutes
    case "$IDLE" in
        '.')    IDLE_MIN=0 ;;
        'old')  IDLE_MIN=$((MAX_IDLE + 1)) ;;
        *:* )   H=${IDLE%%:*}; M=${IDLE##*:}; H=${H#0}; M=${M#0}; [ -z "$H" ] && H=0; [ -z "$M" ] && M=0; IDLE_MIN=$((H*60 + M)) ;;
        *d)     D=${IDLE%%[^0-9]*}; IDLE_MIN=$((D*1440)) ;;
        *)      IDLE_MIN=$((MAX_IDLE + 1)) ;;
    esac

    # PS call
    TTY_PROCS=$($PS -t "$TTY" -o user=)
    PROC_COUNT=$(printf '%s\n' "$TTY_PROCS" | $WC -l)

    case "$TTY_PROCS" in
        *root*) ROOT_LOGIN=true ;;
    esac

    # Count sessions
    if [ "$PROC_COUNT" -ge 1 ] || [ "$IDLE_MIN" -le "$MAX_IDLE" ]; then
        ACTIVE_SESSIONS=$((ACTIVE_SESSIONS + 1))
    fi

    # Age check
    LOGIN_EPOCH=$($DATE -d "$LOGIN_DATE $LOGIN_TIME" +%s 2>/dev/null) || LOGIN_EPOCH=0
    if [ "$LOGIN_EPOCH" -ne 0 ]; then
        AGE_MIN=$(((NOW_EPOCH - LOGIN_EPOCH)/60))
        [ "$AGE_MIN" -gt "$MAX_AGE" ] && AGE_CRIT=true
    fi
done <<EOF
$WHO_OUTPUT
EOF

# Auth failure detection
<% if @systemd_enable -%>
PAT='Failed password|Failed publickey|Invalid user|authentication failure|kex_exchange_identification|userauth_pubkey'
OUT=$($JOURNALCTL -q -o short-unix -u ssh -u sshd --since today | $AWK -v allow="$ALLOWED_USERS" '
BEGIN{
    split(allow,a,","); for(i in a) w[a[i]]=1
    fail_na=0; raw=0; eff=0
}
{
    idx = index($0, ": "); msg = (idx>0 ? substr($0, idx+2) : $0)
    pid = ""
    if (match($0, /sshd\[([0-9]+)\]/, mPid)) pid = mPid[1]
    if (match(msg, /Accepted (password|publickey) for ([[:alnum:]_.-]+)/, mAcc)) {
        acc[pid] = 1
    }
    user = ""
    if (match(msg, /Invalid user[[:space:]]+([[:alnum:]_.-]+)/, mInv)) {
        user = mInv[1]
        if (pid!="") fails[pid]++; else fail_na++
        if (user in w) wl_fail_pid_user[pid ":" user]=1
    } else if (match(msg, /Failed (password|publickey) for (invalid user )?([[:alnum:]_.-]+)/, mFail)) {
        user = mFail[3]
        if (pid!="") fails[pid]++; else fail_na++
        if (user in w) wl_fail_pid_user[pid ":" user]=1
    } else if (msg ~ /authentication failure/) {
        if (pid!="") fails[pid]++; else fail_na++
    } else if (msg ~ /kex_exchange_identification/) {
        if (pid!="") fails[pid]++; else fail_na++
    }
}
END{
    raw = fail_na
    eff = fail_na
    for (pp in fails) {
        raw += fails[pp]
        if (!(pp in acc)) eff += fails[pp]
    }
    sep=""; bad=""
    for (k in wl_fail_pid_user) {
        n = split(k, parts, ":"); pidk=parts[1]; userk=parts[2]
        if (!(pidk in acc) && !(userk in seen)) {
        bad = bad sep userk; sep=","
        seen[userk]=1
        }
    }
    print raw ":" eff ":" bad
}')
# Parse: raw:eff:bad
FAIL_RAW=${OUT%%:*}
TMP=${OUT#*:}
FAIL_EFF=${TMP%%:*}
BAD=${TMP#*:}
<% else -%>
FAIL_RAW=0
FAIL_EFF=0
BAD=""
<% end -%>

# Determine state
if [ "$ROOT_LOGIN" = true ] || [ "$AGE_CRIT" = true ]; then
    STATE_CODE=2
elif [ "$ACTIVE_SESSIONS" -ge "$CRIT_THRESH" ]; then
    STATE_CODE=2
elif [ "$ACTIVE_SESSIONS" -ge "$WARN_THRESH" ]; then
    STATE_CODE=1
fi

# Escalate to WARN if not already WARNING/CRITICAL and we see issues
if [ "$STATE_CODE" -lt 1 ]; then
    if [ "$ZOMBIE_COUNT" -gt 0 ] || [ -n "$BAD" ] || [ "$FAIL_EFF" -gt 0 ]; then
        STATE_CODE=1
    fi
fi

# Create message
EXTRA=""
[ "$ROOT_LOGIN" = true ] && EXTRA="${EXTRA}root login, "
[ "$AGE_CRIT" = true ] && EXTRA="${EXTRA}age> ${MAX_AGE}m, "
[ -n "$BAD" ] && EXTRA="${EXTRA}failed login for '$BAD', "
[ "$FAIL_EFF" -gt 0 ] && EXTRA="${EXTRA}${FAIL_EFF} auth fails, "
[ "$ZOMBIE_COUNT" -gt 0 ] && EXTRA="${EXTRA}${ZOMBIE_COUNT} zombies, "
[ -n "$USERS_LIST" ] && EXTRA="${EXTRA}users=$USERS_LIST, "
EXTRA=$(echo "$EXTRA" | $SED 's/, $//')
[ -n "$EXTRA" ] && EXTRA=" ($EXTRA)"

# Create perfdata
PERF_DATA="sessions=${ACTIVE_SESSIONS};${WARN_THRESH};${CRIT_THRESH};0;"
PERF_DATA="$PERF_DATA zombies=${ZOMBIE_COUNT};;;;"
PERF_DATA="$PERF_DATA fails=${FAIL_RAW};;;;"
PERF_DATA="$PERF_DATA fails_eff=${FAIL_EFF};;;;"
PERF_DATA="$PERF_DATA age_crit=$([ "$AGE_CRIT" = true ] && echo 1 || echo 0);;;;"

# Output
printf '%s active SSH session(s)%s | %s\n' "$ACTIVE_SESSIONS" "$EXTRA" "$PERF_DATA"
exit "$STATE_CODE"
