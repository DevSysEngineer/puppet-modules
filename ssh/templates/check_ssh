#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Binary checks
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
DATE=$(command -v date 2>/dev/null) || die "date not available"
PS=$(command -v ps 2>/dev/null) || die "ps not available"
SED=$(command -v sed 2>/dev/null) || die "sed not available"
<% if @systemd_enable -%>
SYSTEMDCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
JOURNALCTL=$(command -v journalctl 2>/dev/null) || die "journalctl not available"
<% end -%>
WC=$(command -v wc 2>/dev/null) || die "wc not available"
WHO=$(command -v who 2>/dev/null) || die "who not available"

crit() {
    printf '%s\n' "$*" >&2
    exit 2
}

# Defaults / thresholds
ALLOWED_USERS="<%= @check_users_str %>"
CRIT_THRESH=2      # critical session count (active)
WARN_THRESH=1      # warning session count (active)
MAX_IDLE=5         # minutes: session idle-time ≤ MAX_IDLE ⇒ active
MAX_AGE=30         # minutes: session age > MAX_AGE ⇒ CRITICAL
STATE_CODE=0

# Parse options
while getopts 'c:w:i:a:' opt; do
    case "$opt" in
        c) CRIT_THRESH="$OPTARG" ;;
        w) WARN_THRESH="$OPTARG" ;;
        i) MAX_IDLE="$OPTARG" ;;
        a) MAX_AGE="$OPTARG" ;;
        *) die "Usage: $0 [-c <crit>] [-w <warn>] [-t <fail-minutes>] [-i <max-idle>] [-a <max-age>]" ;;
    esac
done

# Service check
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "<%= @service %>" || crit "SSH service is not active"
<% else -%>
$PS -C sshd >/dev/null 2>&1 || crit "SSH service is not active"
<% end -%>

# Analyze current SSH sessions
ACTIVE_SESSIONS=0
AGE_CRIT=false
NOW_EPOCH=$($DATE +%s)
ROOT_LOGIN=false
SEP=""
USERS_LIST=""
WHO_OUTPUT=$($WHO -u)

# Count zombie sshd processes
ZOMBIE_COUNT=$($PS -C sshd -o stat= | $AWK '$0 ~ /Z/ {c++} END {print c+0}')

# Parse who(1) output
while read -r USER TTY LOGIN_DATE LOGIN_TIME IDLE _; do
    # Skip malformed lines / missing TTY
    if [ -z "$USER" ] || [ ! -e "/dev/$TTY" ]; then
        continue
    fi

    # Root session seen via who
    [ "$USER" = "root" ] && ROOT_LOGIN=true

    # Aggregate unique users for message
    case ",$USERS_LIST," in
        *,"$USER",*) ;;
        *) USERS_LIST="${USERS_LIST}${SEP}${USER}"; SEP="," ;;
    esac

    # Determine idle minutes from who(1) IDLE column
    case "$IDLE" in
        '.')    IDLE_MIN=0 ;;
        'old')  IDLE_MIN=$((MAX_IDLE + 1)) ;;
        *:* )   H=${IDLE%%:*}; M=${IDLE##*:}; H=${H#0}; M=${M#0}; [ -z "$H" ] && H=0; [ -z "$M" ] && M=0; IDLE_MIN=$((H*60 + M)) ;;
        *d)     D=${IDLE%%[^0-9]*}; IDLE_MIN=$((D*1440)) ;;
        *)      IDLE_MIN=$((MAX_IDLE + 1)) ;;
    esac

    # Count processes on TTY; also detect root-owned processes on same TTY
    TTY_PROCS=$($PS -t "$TTY" -o user=)
    PROC_COUNT=$(printf '%s\n' "$TTY_PROCS" | $WC -l)
    case "$TTY_PROCS" in
        *root*) ROOT_LOGIN=true ;;
    esac

    # Session considered active if there is at least one process on TTY or IDLE ≤ MAX_IDLE
    if [ "$PROC_COUNT" -ge 1 ] || [ "$IDLE_MIN" -le "$MAX_IDLE" ]; then
        ACTIVE_SESSIONS=$((ACTIVE_SESSIONS + 1))
    fi

    # Age check (CRIT if any session age exceeds MAX_AGE minutes)
    LOGIN_EPOCH=$($DATE -d "$LOGIN_DATE $LOGIN_TIME" +%s 2>/dev/null) || LOGIN_EPOCH=0
    if [ "$LOGIN_EPOCH" -ne 0 ]; then
        AGE_MIN=$(((NOW_EPOCH - LOGIN_EPOCH)/60))
        [ "$AGE_MIN" -gt "$MAX_AGE" ] && AGE_CRIT=true
    fi
done <<EOF
$WHO_OUTPUT
EOF

# Auth failure detection (journalctl)
<% if @systemd_enable -%>
OUT=$($JOURNALCTL -q -o short-unix -u ssh -u sshd --since today | $AWK -v allow_users="$ALLOWED_USERS" '
BEGIN {
    # Parse allowlist into a map for O(1) lookups
    split(allow_users, a, ","); has_allow=0
    for (i in a) if (a[i]!="") { allow_map[a[i]]=1; has_allow=1 }

    # Initialize counters
    fail_no_pid_total=0                # failures with no PID found
    wl_fail_no_pid_total=0             # allowlist failures with no PID
    nl_fail_no_pid_total=0             # non-allowlist failures with no PID
    wl_abort_total=0                   # allowlist "auth aborts" before auth completes
    nl_abort_total=0                   # non-allowlist "auth aborts"
}
{
    # Extract message part and PID
    idx=index($0, ": "); msg=(idx>0?substr($0, idx+2):$0)
    pid=""
    if (match($0,/sshd\[([0-9]+)\]/,mPid)) pid=mPid[1]

    # Mark successful authentications per PID (skip line)
    if (match(msg,/Accepted (password|publickey) for ([[:alnum:]_.-]+)/,mA)) { accepted_pid[pid]=1; next }

    # User-initiated aborts (client closed/reset before auth completes) – NOT failures
    if (match(msg,/(Connection (closed|reset) by authenticating user|Disconnected from authenticating user)[[:space:]]+([[:alnum:]_.-]+)/,mAb)) {
        user=mAb[3]
        if (user in allow_map) wl_abort_total++; else nl_abort_total++
        next
    }

    # Classify failures (optionally with a user)
    is_fail=0; user=""
    if (match(msg,/Invalid user[[:space:]]+([[:alnum:]_.-]+)/,mInv)) { is_fail=1; user=mInv[1] }
    else if (match(msg,/Failed (password|publickey) for (invalid user )?([[:alnum:]_.-]+)/,mF)) { is_fail=1; user=mF[3] }
    else if (msg ~ /authentication failure|kex_exchange_identification/) { is_fail=1 }

    # Accumulate counters
    if (is_fail) {
        # Global totals (independent of user group)
        if (pid!="") fail_by_pid[pid]++; else fail_no_pid_total++

        # Split by allowlist / non-allowlist when user is known
        if (user!="") {
            if (user in allow_map) {
                if (pid!="") wl_fail_by_pid[pid]++; else wl_fail_no_pid_total++
                wl_pid_user_flag[pid ":" user]=1  # remember for "bad" user list (only if no later Accepted)
            } else {
                if (pid!="") nl_fail_by_pid[pid]++; else nl_fail_no_pid_total++
            }
        }
    }
}
END {
    # RAW = all failures (with and without PID)
    raw_fail_total=fail_no_pid_total
    for (pp in fail_by_pid) raw_fail_total+=fail_by_pid[pp]

    # Allowlist unmatched failures = failures without a later Accepted for same PID, plus no-PID bucket
    wl_fail_unmatched_total=0; bad_users=""
    if (has_allow) {
        wl_fail_unmatched_total=wl_fail_no_pid_total
        for (pp in wl_fail_by_pid) if (!(pp in accepted_pid)) wl_fail_unmatched_total+=wl_fail_by_pid[pp]

        # Build unique list of allowlist users that failed (unmatched)
        sep=""
        for (k in wl_pid_user_flag) {
            n=split(k,parts,":"); pidk=parts[1]; userk=parts[2]
            if (!(pidk in accepted_pid) && !(userk in seen)) {
                bad_users=bad_users sep userk; sep=","; seen[userk]=1
            }
        }
    }

    # Non-allowlist totals (mirror allowlist semantics; no status impact)
    # RAW = all non-allowlist failures (with and without PID)
    nl_fail_raw_total=nl_fail_no_pid_total
    for (pp in nl_fail_by_pid) nl_fail_raw_total+=nl_fail_by_pid[pp]

    # UNMATCHED = failures without a later Accepted for the same PID, plus the no-PID bucket
    nl_fail_unmatched_total=nl_fail_no_pid_total
    for (pp in nl_fail_by_pid) if (!(pp in accepted_pid)) nl_fail_unmatched_total+=nl_fail_by_pid[pp]

    # Output fields (order expected by the shell parser):
    # total : wl_unmatched : bad_wl_users : oth_total : oth_unmatched : abort_wl : abort_oth
    print raw_fail_total ":" wl_fail_unmatched_total ":" bad_users ":" \
          nl_fail_raw_total ":" nl_fail_unmatched_total ":" wl_abort_total ":" nl_abort_total
}
')
# Parse new names
FAIL_TOTAL=${OUT%%:*}; REM=${OUT#*:}
FAIL_WL_UNMATCHED=${REM%%:*}; REM=${REM#*:}
BAD_WL_USERS=${REM%%:*}; REM=${REM#*:}
FAIL_OTH_TOTAL=${REM%%:*}; REM=${REM#*:}
FAIL_OTH_UNMATCHED=${REM%%:*}; REM=${REM#*:}
ABORT_WL=${REM%%:*}; ABORT_OTH=${REM#*:}
<% else -%>
FAIL_TOTAL=0
FAIL_WL_UNMATCHED=0
BAD_WL_USERS=""
FAIL_OTH_TOTAL=0
FAIL_OTH_UNMATCHED=0
ABORT_WL=0
ABORT_OTH=0
<% end -%>

# Determine state
if [ "$ROOT_LOGIN" = true ] || [ "$AGE_CRIT" = true ]; then
    STATE_CODE=2
elif [ "$ACTIVE_SESSIONS" -ge "$CRIT_THRESH" ]; then
    STATE_CODE=2
elif [ "$ACTIVE_SESSIONS" -ge "$WARN_THRESH" ]; then
    STATE_CODE=1
fi

# Escalate to WARN if not already WARNING/CRITICAL and we see issues (allowlist only)
if [ "$STATE_CODE" -lt 1 ]; then
    if [ "$ZOMBIE_COUNT" -gt 0 ] || [ -n "$BAD_WL_USERS" ] || [ "$FAIL_WL_UNMATCHED" -gt 0 ] ; then
        STATE_CODE=1
    fi
fi

# Human-readable message
EXTRA=""
[ "$ROOT_LOGIN" = true ] && EXTRA="${EXTRA}root login, "
[ "$AGE_CRIT" = true ] && EXTRA="${EXTRA}age> ${MAX_AGE}m, "
[ -n "$BAD_WL_USERS" ] && EXTRA="${EXTRA}failed login for '$BAD_WL_USERS', "
[ "$FAIL_WL_UNMATCHED" -gt 0 ] && EXTRA="${EXTRA}${FAIL_WL_UNMATCHED} unmatched fails (allowlist), "
[ "$ZOMBIE_COUNT" -gt 0 ] && EXTRA="${EXTRA}${ZOMBIE_COUNT} zombies, "
[ -n "$USERS_LIST" ] && EXTRA="${EXTRA}users=$USERS_LIST, "
EXTRA=$(echo "$EXTRA" | $SED 's/, $//')
[ -n "$EXTRA" ] && EXTRA=" ($EXTRA)"

# Perfdata
PERF_DATA="sessions=${ACTIVE_SESSIONS};${WARN_THRESH};${CRIT_THRESH};0;"
PERF_DATA="$PERF_DATA zombies=${ZOMBIE_COUNT};;;;"
PERF_DATA="$PERF_DATA fail_total=${FAIL_TOTAL};;;;"
PERF_DATA="$PERF_DATA fail_wl_unmatched=${FAIL_WL_UNMATCHED};;;;"
PERF_DATA="$PERF_DATA fail_oth_total=${FAIL_OTH_TOTAL};;;;"
PERF_DATA="$PERF_DATA fail_oth_unmatched=${FAIL_OTH_UNMATCHED};;;;"
PERF_DATA="$PERF_DATA abort_wl=${ABORT_WL};;;;"
PERF_DATA="$PERF_DATA abort_oth=${ABORT_OTH};;;;"
PERF_DATA="$PERF_DATA age_crit=$([ "$AGE_CRIT" = true ] && echo 1 || echo 0);;;;"

# Output for monitoring
printf '%s active SSH session(s)%s | %s\n' "$ACTIVE_SESSIONS" "$EXTRA" "$PERF_DATA"
exit "$STATE_CODE"
