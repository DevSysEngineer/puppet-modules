#!/bin/sh

# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Locate awk
AWK=$(command -v awk 2>/dev/null)
[ -n "$AWK" ] || die "akw not available"

# Locate date
DATE=$(command -v date 2>/dev/null)
[ -n "$DATE" ] || die "date not available"

# Locate grep
GREP=$(command -v grep 2>/dev/null)
[ -n "$GREP" ] || die "grep not available"

# Locate printf
PRINTF=$(command -v printf 2>/dev/null)
[ -n "$PRINTF" ] || die "printf not available"

# Locate mktemp
MKTEMP=$(command -v mktemp 2>/dev/null)
[ -n "$MKTEMP" ] || die "mktemp not available"

# Locate systemctl
SYSTEMCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMCTL" ] || die "systemctl not available"

# Locate sed
SED=$(command -v sed 2>/dev/null)
[ -n "$SED" ] || die "sed not available"

# Locate tr
TR=$(command -v tr 2>/dev/null)
[ -n "$TR" ] || die "tr not available"

# Locate cut
CUT=$(command -v cut 2>/dev/null)
[ -n "$CUT" ] || die "cut not available"

# Locate RM
RM=$(command -v cut 2>/dev/null)
[ -n "$RM" ] || die "cut not available"

<% if @systemd_enable -%>
# Locate systemctl
SYSTEMDCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMDCTL" ] || die "systemctl not available"
<% else -%>
# Locate ps
PS=$(command -v ps 2>/dev/null)
[ -n "$PS" ] || die "ps not available"
<% end -%>

crit() {
    $PRINTF '%s\n' "$*" >&2
    exit 2
}

# Defaults
CONFIG="/opt/mirthconnect/conf/mirth-cli-config.properties"
GRACE=600 # seconds before CRITICAL for queues
STATE_FILE="/tmp/mirth_queue_state.txt"
MCCOMMAND="/usr/local/bin/mccommand"
SERVICE="mcservice.service"
TMPDIR="/tmp"
WARN_Q=25 # queuedâ€‘message threshold

# Options 
while getopts 'c:t:w:' opt; do
    case "$opt" in
        c) CONFIG="$OPTARG" ;;
        t) GRACE="$OPTARG" ;;
        w) WARN_Q="$OPTARG" ;;
        *) die "Usage: $0 [-c <config_file>] [-t <seconds>] [-w <queue>]" ;;
    esac
done

# Service running
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "<%= @service %>" || crit "Mirth Connect service is not active"
<% else -%>
$PS -C mcservice >/dev/null 2>&1 || crit "Mirth Connect service is not active"
<% end -%>

# Workspace
WORK_DIR=$($MKTEMP -d "$TMPDIR/mirthcheck.XXXXXX") || die "mktemp failed"
trap '$RM -rf "$WORK_DIR"' EXIT HUP INT QUIT TERM

# Collect CLI output
$PRINTF 'channel stats *\n' >"$WORK_DIR/cli.cmd"
OUTPUT_RAW=$($MCCOMMAND -c "$CONFIG" -s "$WORK_DIR/cli.cmd" 2>&1) || die "mccommand failed"
[ -n "$OUTPUT_RAW" ] || crit "Empty output from mccommand"

# Strip CR/ANSI/control
OUTPUT_CLEAN=$($PRINTF '%s\n' "$OUTPUT_RAW" \
    | $TR -d '\r' \
    | $SED -E 's/\x1B\[[0-9;]*[A-Za-z]//g' \
    | $TR -cd '\11\12\40-\176')

# Parse & aggregate with AWK
# Emit lines:
#   C|name|group|status|queue|received|sent
#   G|group|received_total|sent_total
#   T|received_total|sent_total
$PRINTF '%s\n' "$OUTPUT_CLEAN" | $AWK '
    BEGIN{FS=": +"}
    function emit(){
        if(chan!=""){ 
            # defaults
            if(group=="") group="ungrouped";
            if(status=="") status="Unknown";
            if(q=="") q=0; if(recv=="") recv=0; if(sent=="") sent=0;
            printf "C|%s|%s|%s|%d|%d|%d\n", chan, group, status, q+0, recv+0, sent+0;
            g_recv[group]+=recv+0; g_sent[group]+=sent+0;
            t_recv+=recv+0; t_sent+=sent+0;
        }
        chan=""; group=""; status=""; q=recv=sent=0;
    }
    /^Channel Stats for/{emit(); sub(/^Channel Stats for +/,"",$0); chan=$0}
    /^Channel Group:/{group=$2}
    /^Group:/{if(group=="") group=$2}
    /^Status:/{status=$2}
    /^Queued:/{gsub(",","",$2); q=$2+0}
    /^Received:/{gsub(",","",$2); recv=$2+0}
    /^Sent:/{gsub(",","",$2); sent=$2+0}
    END{
        emit();
        for(g in g_recv){ printf "G|%s|%d|%d\n", g, g_recv[g]+0, g_sent[g]+0 }
        printf "T|%d|%d\n", t_recv+0, t_sent+0
    }
' > "$WORK_DIR/parsed_all.txt"

# Split for convenience
$GREP '^C|' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_channels.txt"
$GREP '^G|' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_groups.txt"
$GREP '^T|' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_totals.txt"

TOTAL_CHANS=$($WC -l <"$WORK_DIR/parsed_channels.txt" 2>/dev/null || echo 0)
NOW=$($DATE +%s)
QUEUE_ISSUES=0
STATUS_ISSUES=0
QUEUE_CRIT=0
SUMMARY_QUEUE=""
SUMMARY_STATUS=""

# Check if state file exists
[ -f "$STATE_FILE" ] && PREV_STATE=$(cat "$STATE_FILE") || PREV_STATE=""

# Evaluate per channel
while IFS='|' read -r _prefix chan group status q recv sent; do
    # Status
    case "$status" in
        Started) : ;;
        *) STATUS_ISSUES=$((STATUS_ISSUES+1)); SUMMARY_STATUS="${SUMMARY_STATUS}${chan}(${status}), " ;;
    esac

    # Queue
    if [ "${q:-0}" -gt "$WARN_Q" ]; then
        FIRST=$($PRINTF '%s\n' "$PREV_STATE" | $GREP -F "${chan}|" | $CUT -d'|' -f2)
        [ -z "$FIRST" ] && FIRST=$NOW
        $PRINTF '%s|%s\n' "$chan" "$FIRST" >>"$WORK_DIR/new_state"

        # If the queue is above the threshold for longer than the grace period, set critical
        [ $((NOW - FIRST)) -ge "$GRACE" ] && QUEUE_CRIT=1
        
        QUEUE_ISSUES=$((QUEUE_ISSUES+1))
        SUMMARY_QUEUE="${SUMMARY_QUEUE}${chan}(${q}), "
    fi
done <"$WORK_DIR/parsed_channels.txt"

# Persist new state (only channels still breaching threshold)
if [ -f "$WORK_DIR/new_state" ]; then
    $MV "$WORK_DIR/new_state" "$STATE_FILE"
else
    [ -f "$STATE_FILE" ] && $RM -f "$STATE_FILE"
fi

# Trim trailing comma+space
SUMMARY_QUEUE=${SUMMARY_QUEUE%%, }
SUMMARY_STATUS=${SUMMARY_STATUS%%, }

# Build perfdata
PERF="channels=${TOTAL_CHANS} queues=${QUEUE_ISSUES};0;${WARN_Q} status_issues=${STATUS_ISSUES}"

# Totals
if read -r _t tot_recv tot_sent <"$WORK_DIR/parsed_totals.txt"; then
    PERF="$PERF total_received=${tot_recv} total_sent=${tot_sent}"
fi

# Per group
while IFS='|' read -r _g group grecv gsent; do
    # sanitize label: lower, spaces->_, strip non [A-Za-z0-9_]
    lbl=$(printf '%s' "$group" | $TR '[:upper:]' '[:lower:]' | $TR ' ' '_' | $SED 's/[^A-Za-z0-9_]/_/g')
    PERF="$PERF group_${lbl}_received=${grecv} group_${lbl}_sent=${gsent}"
done <"$WORK_DIR/parsed_groups.txt"

# Result
if [ "$STATUS_ISSUES" -gt 0 ]; then
    crit "${STATUS_ISSUES} channel(s) halted/stopped: ${SUMMARY_STATUS} | ${PERF}"
elif [ "$QUEUE_CRIT" -eq 1 ]; then
    crit "${QUEUE_ISSUES} channel(s) queue >${WARN_Q} (${GRACE}s): ${SUMMARY_QUEUE} | ${PERF}"
elif [ "$QUEUE_ISSUES" -gt 0 ]; then
    echo "${QUEUE_ISSUES} channel(s) queue >${WARN_Q}: ${SUMMARY_QUEUE} | ${PERF}"
    exit 1
fi

echo "${TOTAL_CHANS} channel(s) running | ${PERF}"
exit 0