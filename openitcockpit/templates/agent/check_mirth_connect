#!/bin/sh

# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Locate awk
AWK=$(command -v awk 2>/dev/null)
[ -n "$AWK" ] || die "akw not available"

# Locate date
DATE=$(command -v date 2>/dev/null)
[ -n "$DATE" ] || die "date not available"

# Locate grep
GREP=$(command -v grep 2>/dev/null)
[ -n "$GREP" ] || die "grep not available"

# Locate printf
PRINTF=$(command -v printf 2>/dev/null)
[ -n "$PRINTF" ] || die "printf not available"

# Locate mktemp
MKTEMP=$(command -v mktemp 2>/dev/null)
[ -n "$MKTEMP" ] || die "mktemp not available"

# Locate systemctl
SYSTEMCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMCTL" ] || die "systemctl not available"

# Locate sed
SED=$(command -v sed 2>/dev/null)
[ -n "$SED" ] || die "sed not available"

# Locate tr
TR=$(command -v tr 2>/dev/null)
[ -n "$TR" ] || die "tr not available"

# Locate cut
CUT=$(command -v cut 2>/dev/null)
[ -n "$CUT" ] || die "cut not available"

# Locate RM
RM=$(command -v rm 2>/dev/null)
[ -n "$RM" ] || die "rm not available"

<% if @systemd_enable -%>
# Locate systemctl
SYSTEMDCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMDCTL" ] || die "systemctl not available"
<% else -%>
# Locate ps
PS=$(command -v ps 2>/dev/null)
[ -n "$PS" ] || die "ps not available"
<% end -%>

crit() {
    $PRINTF '%s\n' "$*" >&2
    exit 2
}

# Defaults
CONFIG="/opt/mirthconnect/conf/mirth-cli-config.properties"
GRACE=600 # seconds before CRITICAL for queues
MCCOMMAND="/usr/local/bin/mccommand"
NOW=$($DATE +%s)
QUEUE_CRIT=0
QUEUE_ISSUES=0
SERVICE="mcservice.service"
STATE_FILE="/tmp/mirth_queue_state.txt"
STATUS_ISSUES=0
SUMMARY_QUEUE=""
SUMMARY_STATUS=""
TMPDIR="/tmp"
WARN_Q=25 # queued‑message threshold

# Options 
while getopts 'c:t:w:' opt; do
    case "$opt" in
        c) CONFIG="$OPTARG" ;;
        t) GRACE="$OPTARG" ;;
        w) WARN_Q="$OPTARG" ;;
        *) die "Usage: $0 [-c <config_file>] [-t <seconds>] [-w <queue>]" ;;
    esac
done

# Service running
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "$SERVICE" || crit "Mirth Connect service is not active"
<% else -%>
$PS -C mcservice >/dev/null 2>&1 || crit "Mirth Connect service is not active"
<% end -%>

# Workspace
WORK_DIR=$($MKTEMP -d "$TMPDIR/mirthcheck.XXXXXX") || die "mktemp failed"
trap '$RM -rf "$WORK_DIR"' EXIT HUP INT QUIT TERM

# Collect channel stats
$PRINTF 'channel stats *\n' >"$WORK_DIR/cli_stats.cmd"
OUTPUT_RAW=$($MCCOMMAND -c "$CONFIG" -s "$WORK_DIR/cli_stats.cmd" 2>&1) || die "mccommand stats failed"
[ -n "$OUTPUT_RAW" ] || crit "Empty output from mccommand stats"

# Parse stats → C/G/T records
OUTPUT_CLEAN=$($PRINTF '%s\n' "$OUTPUT_RAW" | $TR -d '\r' | $SED -E 's/\x1B\[[0-9;]*[A-Za-z]//g' | $TR -cd '\11\12\40-\176')
$PRINTF '%s\n' "$OUTPUT_CLEAN" | $AWK '
    function after_colon(s){ sub(/^[^:]+:[[:space:]]*/,"",s); return s }
    function emit(){
        if (chan!="") {
            if (group=="") group="ungrouped";
            if (status=="") status="";             # status komt uit tweede call
            if (q=="") q=0; if (recv=="") recv=0; if (sent=="") sent=0;
            printf "C|%s|%s|%s|%d|%d|%d\n", chan, group, status, q+0, recv+0, sent+0;
            g_recv[group]+=recv+0; g_sent[group]+=sent+0; t_recv+=recv+0; t_sent+=sent+0;
        }
        chan=""; group=""; status=""; q=recv=sent=0;
    }
    BEGIN { chan=""; group=""; status=""; q=recv=sent=0 }
    /^Channel Stats for[[:space:]]+/ { emit(); sub(/^Channel Stats for[[:space:]]+/,"",$0); chan=$0; next }
    /^Channel Group:/ { group=after_colon($0); next }
    /^Group:/ { if(group=="") group=after_colon($0); next }
    /^Queued:/ { v=after_colon($0); gsub(",","",v); q=v+0; next }
    /^Received:/ { v=after_colon($0); gsub(",","",v); recv=v+0; next }
    /^Sent:/ { v=after_colon($0); gsub(",","",v); sent=v+0; next }
    END {
        emit();
        for (g in g_recv) printf "G|%s|%d|%d\n", g, g_recv[g]+0, g_sent[g]+0;
        printf "T|%d|%d\n", t_recv+0, t_sent+0;
    }
' >"$WORK_DIR/parsed_all.txt"

# Split to helper files (zonder grep)
$AWK -F'|' '/^C\|/ {print}' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_channels.txt"
$AWK -F'|' '/^G\|/ {print}' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_groups.txt"
$AWK -F'|' '/^T\|/ {print}' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_totals.txt"

# Collect channel status
$PRINTF 'status\n' >"$WORK_DIR/cli_status.cmd"
STATUS_RAW=$($MCCOMMAND -c "$CONFIG" -s "$WORK_DIR/cli_status.cmd" 2>&1) || die "mccommand status failed"
[ -n "$STATUS_RAW" ] || crit "Empty output from mccommand status"

# Build status map: name|status
STATUS_CLEAN=$($PRINTF '%s\n' "$STATUS_RAW" | $TR -d '\r' | $SED -E 's/\x1B\[[0-9;]*[A-Za-z]//g' | $TR -cd '\11\12\40-\176')
$PRINTF '%s\n' "$STATUS_CLEAN" | $AWK '
    BEGIN{skip=1}
    /^ID[[:space:]]+Status[[:space:]]+Name/ { skip=0; next }
    skip==1 { next }
    NF<3 { next }
    {
        st=$2; name=""; for(i=3;i<=NF;i++) name=(i==3?$i:name FS $i);
        print name "|" st
    }
' >"$WORK_DIR/status_map.txt"

# Set variables
TOTAL_CHANS=$($AWK -F'|' '/^C\|/ {c++} END{print c+0}' "$WORK_DIR/parsed_channels.txt")

# Evaluate per channel
# Load previous state file into temp (may not exist)
[ -f "$STATE_FILE" ] || :

while IFS='|' read -r _c chan group status q recv sent; do
    # Fill status from map using awk lookup
    status_lookup=$($AWK -F'|' -v c="$chan" '$1==c{print $2; exit}' "$WORK_DIR/status_map.txt")
    [ -n "$status_lookup" ] && status="$status_lookup"

    case "$status" in
        [Ss][Tt][Aa][Rr][Tt][Ee][Dd]*) : ;;
        *) STATUS_ISSUES=$((STATUS_ISSUES+1)); SUMMARY_STATUS="${SUMMARY_STATUS}${chan}(${status}), ";;
    esac

    # Queue threshold handling with grace window
    if [ "${q:-0}" -gt "$WARN_Q" ]; then
        FIRST=$($AWK -F'|' -v c="$chan" '$1==c{print $2; found=1; exit} END{if(!found) print ""}' "$STATE_FILE" 2>/dev/null)
        [ -z "$FIRST" ] && FIRST=$NOW
        $PRINTF '%s|%s\n' "$chan" "$FIRST" >>"$WORK_DIR/new_state"

        # If the queue is above the threshold for longer than the grace period, set critical
        [ $((NOW - FIRST)) -ge "$GRACE" ] && QUEUE_CRIT=1

        # Update variables
        QUEUE_ISSUES=$((QUEUE_ISSUES+1))
        SUMMARY_QUEUE="${SUMMARY_QUEUE}${chan}(${q}), "
    fi
done <"$WORK_DIR/parsed_channels.txt"

# Persist new state (only channels still breaching threshold)
if [ -f "$WORK_DIR/new_state" ]; then
    $MV "$WORK_DIR/new_state" "$STATE_FILE"
else
    [ -f "$STATE_FILE" ] && $RM -f "$STATE_FILE"
fi

# Trim trailing comma+space
SUMMARY_QUEUE=${SUMMARY_QUEUE%%, }
SUMMARY_STATUS=${SUMMARY_STATUS%%, }

# Build perfdata
RUNNING_OK=$((TOTAL_CHANS - STATUS_ISSUES))
PERF="channels=${TOTAL_CHANS} queues=${QUEUE_ISSUES};0;${WARN_Q} status_issues=${STATUS_ISSUES} running_ok=${RUNNING_OK} running_down=${STATUS_ISSUES}"

# Totals
if IFS='|' read -r _t tot_recv tot_sent <"$WORK_DIR/parsed_totals.txt"; then
    PERF="$PERF total_received=${tot_recv} total_sent=${tot_sent}"
fi

# Per group
while IFS='|' read -r _g group grecv gsent; do
    lbl=$(printf '%s' "$group" | $TR '[:upper:]' '[:lower:]' | $TR ' ' '_' | $SED 's/[^A-Za-z0-9_]/_/g')
    PERF="$PERF group_${lbl}_received=${grecv} group_${lbl}_sent=${gsent}"
done <"$WORK_DIR/parsed_groups.txt"

# Result
if [ "$STATUS_ISSUES" -gt 0 ]; then
    crit "${STATUS_ISSUES} channel(s) not started: ${SUMMARY_STATUS} | ${PERF}"
elif [ "$QUEUE_CRIT" -eq 1 ]; then
    crit "${QUEUE_ISSUES} channel(s) queue >${WARN_Q} (${GRACE}s): ${SUMMARY_QUEUE} | ${PERF}"
elif [ "$QUEUE_ISSUES" -gt 0 ]; then
    echo "${QUEUE_ISSUES} channel(s) queue >${WARN_Q}: ${SUMMARY_QUEUE} | ${PERF}"
    exit 1
fi

echo "${TOTAL_CHANS} channel(s) OK | ${PERF}"
exit 0
