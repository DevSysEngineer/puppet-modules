#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Locate awk
AWK=$(command -v awk 2>/dev/null)
[ -n "$AWK" ] || die "akw not available"

# Locate date
DATE=$(command -v date 2>/dev/null)
[ -n "$DATE" ] || die "date not available"

# Locate printf
PRINTF=$(command -v printf 2>/dev/null)
[ -n "$PRINTF" ] || die "printf not available"

# Locate mktemp
MKTEMP=$(command -v mktemp 2>/dev/null)
[ -n "$MKTEMP" ] || die "mktemp not available"

# Locate sed
SED=$(command -v sed 2>/dev/null)
[ -n "$SED" ] || die "sed not available"

# Locate tr
TR=$(command -v tr 2>/dev/null)
[ -n "$TR" ] || die "tr not available"

# Locate rm
RM=$(command -v rm 2>/dev/null)
[ -n "$RM" ] || die "rm not available"

# Locate mv
MV=$(command -v mv 2>/dev/null)
[ -n "$MV" ] || die "mv not available"

<% if @systemd_enable -%>
# Locate systemctl
SYSTEMDCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMDCTL" ] || die "systemctl not available"
<% else -%>
# Locate ps
PS=$(command -v ps 2>/dev/null)
[ -n "$PS" ] || die "ps not available"
<% end -%>

crit() {
    $PRINTF '%s\n' "$*" >&2
    exit 2
}

# Defaults
CONFIG="/opt/mirthconnect/conf/mirth-cli-config.properties"
CRIT_Q=30
GRACE=600 # seconds before CRITICAL for queues
MCCOMMAND="/usr/local/bin/mccommand"
NOW=$($DATE +%s)
QUEUE_CRIT=0
QUEUE_ISSUES=0
MAX_Q=0
STATE_FILE="/tmp/mirth_queue_state.txt"
STATUS_ISSUES=0
SUMMARY_QUEUE=""
SUMMARY_STATUS=""
WARN_Q=25 # queued‑message threshold

# Options 
while getopts 'c:t:w:' opt; do
    case "$opt" in
        c) CONFIG="$OPTARG" ;;
        t) GRACE="$OPTARG" ;;
        w) WARN_Q="$OPTARG" ;;
        *) die "Usage: $0 [-c <config_file>] [-t <seconds>] [-w <queue>]" ;;
    esac
done

# Service running
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "mcservice.service" || crit "Mirth Connect service is not active"
<% else -%>
$PS -C mcservice >/dev/null 2>&1 || crit "Mirth Connect service is not active"
<% end -%>

# Workdir
WORK_DIR=$($MKTEMP -d "/tmp/mirthcheck.XXXXXX") || die "mktemp failed"
trap '$RM -rf "$WORK_DIR"' EXIT HUP INT QUIT TERM

# Stats
$PRINTF 'channel stats *\n' >"$WORK_DIR/cli_stats.cmd"
OUTPUT_RAW=$($MCCOMMAND -c "$CONFIG" -s "$WORK_DIR/cli_stats.cmd" 2>&1) || die "mccommand stats failed"
[ -n "$OUTPUT_RAW" ] || crit "Empty output from mccommand stats"

# Parse stats → C/T
OUTPUT_CLEAN=$($PRINTF '%s\n' "$OUTPUT_RAW" | $TR -d '\r' | $SED -E 's/\x1B\[[0-9;]*[A-Za-z]//g' | $TR -cd '\11\12\40-\176')
$PRINTF '%s\n' "$OUTPUT_CLEAN" | $AWK '
  function after_colon(s){ sub(/^[^:]+:[[:space:]]*/,"",s); return s }
  function emit(){
    if (chan!="") {
      if (q=="") q=0; if (recv=="") recv=0; if (sent=="") sent=0;
      printf "C|%s|%d|%d|%d\n", chan, q+0, recv+0, sent+0;
      t_recv+=recv+0; t_sent+=sent+0;
    }
    chan=""; q=recv=sent=0;
  }
  BEGIN { chan=""; q=recv=sent=0; t_recv=0; t_sent=0 }
  /^Channel Stats for[[:space:]]+/ { emit(); sub(/^Channel Stats for[[:space:]]+/,"",$0); chan=$0; next }
  /^Queued:/   { v=after_colon($0); gsub(",","",v); q=v+0; next }
  /^Received:/ { v=after_colon($0); gsub(",","",v); recv=v+0; next }
  /^Sent:/     { v=after_colon($0); gsub(",","",v); sent=v+0; next }
  END { emit(); printf "T|%d|%d\n", t_recv+0, t_sent+0; }
' >"$WORK_DIR/parsed_all.txt"

$AWK -F'|' '/^C\|/ {print}' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_channels.txt"
$AWK -F'|' '/^T\|/ {print}' "$WORK_DIR/parsed_all.txt" >"$WORK_DIR/parsed_totals.txt"

# Status
$PRINTF 'status\n' >"$WORK_DIR/cli_status.cmd"
STATUS_RAW=$($MCCOMMAND -c "$CONFIG" -s "$WORK_DIR/cli_status.cmd" 2>&1) || die "mccommand status failed"
[ -n "$STATUS_RAW" ] || crit "Empty output from mccommand status"

# status_map.txt → name|Status
STATUS_CLEAN=$($PRINTF '%s\n' "$STATUS_RAW" | $TR -d '\r' | $SED -E 's/\x1B\[[0-9;]*[A-Za-z]//g' | $TR -cd '\11\12\40-\176')
$PRINTF '%s\n' "$STATUS_CLEAN" | $AWK '
  BEGIN{in_tbl=0}
  /^ID[[:space:]]+Status[[:space:]]+Name/ { in_tbl=1; next }
  in_tbl==0 { next }
  NF<3 { next }
  { st=$2; name=""; for(i=3;i<=NF;i++) name=(i==3?$i:name FS $i); print name "|" st }
' >"$WORK_DIR/status_map.txt"

# Init
TOTAL_CHANS=$($AWK -F'|' '/^C\|/ {c++} END{print c+0}' "$WORK_DIR/parsed_channels.txt")
STATE_IN="$STATE_FILE"; [ -f "$STATE_IN" ] || STATE_IN=/dev/null

# Evaluate
while IFS='|' read -r _c chan q recv sent; do
    # Set max q
    [ "${q:-0}" -gt "$MAX_Q" ] && MAX_Q="$q"

    # Get status
    STATUS=$($AWK -F'|' -v c="$chan" '$1==c{print $2; exit}' "$WORK_DIR/status_map.txt")
    case "$STATUS" in
        [Ss][Tt][Aa][Rr][Tt][Ee][Dd]*) : ;;
        *) STATUS_ISSUES=$((STATUS_ISSUES+1)); SUMMARY_STATUS="${SUMMARY_STATUS}${chan}(${STATUS:-Unknown}), ";;
    esac

    if [ "${q:-0}" -gt "$WARN_Q" ]; then
        FIRST=$($AWK -F'|' -v c="$chan" '$1==c{print $2; exit}' "$STATE_IN")
        [ -z "$FIRST" ] && FIRST=$NOW
        $PRINTF '%s|%s\n' "$chan" "$FIRST" >>"$WORK_DIR/new_state"

        # If the queue is above the threshold for longer than the grace period, set critical
        [ $((NOW - FIRST)) -ge "$GRACE" ] && QUEUE_CRIT=1

        # Update variables
        QUEUE_ISSUES=$((QUEUE_ISSUES+1))
        SUMMARY_QUEUE="${SUMMARY_QUEUE}${chan}(${q}), "
    fi
done <"$WORK_DIR/parsed_channels.txt"

# State write
if [ -f "$WORK_DIR/new_state" ]; then
    $MV "$WORK_DIR/new_state" "$STATE_FILE"
else
    [ -f "$STATE_FILE" ] && $RM -f "$STATE_FILE"
fi

# Trim
SUMMARY_QUEUE=${SUMMARY_QUEUE%%, }
SUMMARY_STATUS=${SUMMARY_STATUS%%, }

# Perfdata
PERF_DATA="channels=${TOTAL_CHANS};;;0 queue=${MAX_Q};${WARN_Q};${CRIT_Q};0 issues=${STATUS_ISSUES};;1;0"
if IFS='|' read -r _t tot_recv tot_sent <"$WORK_DIR/parsed_totals.txt"; then
    PERF_DATA="$PERF_DATA total_received=${tot_recv}c;;;0 total_sent=${tot_sent}c;;;0"
fi

# Result
if [ "$STATUS_ISSUES" -gt 0 ]; then
    crit "${STATUS_ISSUES} channel(s) not running: ${SUMMARY_STATUS} | ${PERF_DATA}"
elif [ "$QUEUE_CRIT" -eq 1 ]; then
    crit "${QUEUE_ISSUES} channel(s) queue >${WARN_Q} (${GRACE}s): ${SUMMARY_QUEUE} | ${PERF_DATA}"
elif [ "$QUEUE_ISSUES" -gt 0 ]; then
    echo "${QUEUE_ISSUES} channel(s) queue >${WARN_Q}: ${SUMMARY_QUEUE} | ${PERF_DATA}"
    exit 1
fi

echo "${TOTAL_CHANS} channel(s) OK | ${PERF_DATA}"
exit 0