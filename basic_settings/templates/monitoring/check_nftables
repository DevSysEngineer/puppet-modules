#!/bin/sh

# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Locate awk
AWK=$(command -v awk 2>/dev/null)
[ -n "$AWK" ] || die "awk not available"

# Locate printf
PRINTF=$(command -v printf 2>/dev/null)
[ -n "$PRINTF" ] || die "printf not available"

# Locate lsmod
LSMOD=$(command -v lsmod 2>/dev/null)
[ -n "$LSMOD" ] || die "lsmod not available"

# Locate nft
NFT=$(command -v nft 2>/dev/null)
[ -n "$NFT" ] || die "nft not available"

<% if @systemd_enable -%>
# Locate systemctl
SYSTEMCTL=$(command -v systemctl 2>/dev/null)
[ -n "$SYSTEMCTL" ] || die "systemctl not available"

<% end -%>
# Locate tr
TR=$(command -v tr 2>/dev/null)
[ -n "$TR" ] || die "tr not available"

# Set some default values
BL_ITEMS=0
CHAIN_EMPTY=""
PERF_DATA=""
RULES_TOTAL=0
SEQ=0
TABLE_COUNT=0
TABLE_EMPTY=""
TABLE_PERF=""
TOTAL_RULES=0

crit() {
    $PRINTF '%s\n' "$*" >&2
    exit 2
}

add_pd() {
    LABEL_FORMAT=$($PRINTF '%s' "$1" | $TR -c 'A-Za-z0-9_' '_')
    PERF_DATA="${PERF_DATA}${LABEL_FORMAT}=${2:-0}c "
}

<% if @systemd_enable -%>
# Check if nftables is running
$SYSTEMCTL is-active --quiet "nftables" || crit "nftables service is not active"

<% end -%>

# Kernel‑check
$LSMOD | $AWK '/\bnf_tables\b/' >/dev/null 2>&1 || crit "nf_tables kernel module not loaded"

# Try to get ruleset
RULESET=$($NFT list ruleset 2>/dev/null) || crit "cannot get ruleset"
[ -z "$RULESET" ] && crit "Ruleset empty"

# Analyze ruleset
KEYVALS=$(printf '%s\n' "$RULESET" | $AWK '
BEGIN {
    FS=" "; SUBSEP=SUBSEP; inside=0; tblkey=""; chainkey="";
}
{
    if ($1 == "table") { fam=$2; tab=$3; tblkey=fam SUBSEP tab; next }
    if ($1 == "chain") { inside=1; ch=$2; chainkey=tblkey SUBSEP ch; chain_seen[chainkey]=1; next }
    if (inside && $0 ~ /^[[:space:]]*}/) { inside=0; next }
    if (inside) {
        if ($0 ~ /^[[:space:]]*$/) next
        if ($0 ~ /^[[:space:]]*#/) next
        if ($1 == "type" || $1 == "policy") { chain_has_meta[chainkey]=1; next }
        if ($1 ~ /^(set|counter|flags|elements|size|timeout)$/) next
        rules_in_chain[chainkey]++
    }
}
END {
    total_rules=0; perf=""; empty_tables=""; empty_chains="";
    for (ck in chain_seen) {
        split(ck,a,SUBSEP); fam=a[1]; tab=a[2]; ch=a[3];
        rc = (ck in rules_in_chain) ? rules_in_chain[ck] : 0;
        if (!rc && !(ck in chain_has_meta)) empty_chains = empty_chains " " fam"/"tab"/"ch;
        table_key=fam SUBSEP tab; table_rules[table_key]+=rc;
    }
    for (t in table_rules) {
        split(t,b,SUBSEP); fam=b[1]; tab=b[2]; rc=table_rules[t];
        perf = perf "table_"fam"_"tab"=" rc " ";
        if (!rc) empty_tables = empty_tables " " fam"/"tab;
        total_rules+=rc; tblcount++;
    }
    printf "rules_total=%d\n", total_rules;
    printf "table_count=%d\n", tblcount;
    printf "table_perf=%s\n",  perf;
    printf "table_empty=%s\n", empty_tables;
    printf "chain_empty=%s\n",  empty_chains;
}')

# Parse keyvals
while IFS='=' read -r K V; do
    case "$K" in
        rules_total) TOTAL_RULES=$V ;;
        table_count) TABLE_COUNT=$V ;;
        table_perf)  TABLE_PERF=$V  ;;
        table_empty) TABLE_EMPTY=$V ;;
        chain_empty) CHAIN_EMPTY=$V ;;
    esac
done <<EOF
$KEYVALS
EOF

# Get dynamic sets
DYNSETS=$($PRINTF '%s\n' "$RULESET" | $AWK '
BEGIN { RS="\n"; fam=""; tab=""; inst=0; dyn=0; setn="" }
{
    if ($1=="table") { fam=$2; tab=$3 }
    if ($1=="set")   { setn=$2; dyn=(index($0,"dynamic")>0); inst=1; next }
    if (inst) {
        if (index($0,"dynamic")>0) dyn=1
        if ($0 ~ /}/) {
            if (dyn) print fam, tab, setn
            inst=0; dyn=0
        }
    }
}')

# Read data
BL_ITEMS=0
while read -r FAM TAB SET; do
    [ -z "$FAM" ] && continue
    CNT=$($NFT list set "$FAM" "$TAB" "$SET" 2>/dev/null | $AWK -v RS='' '
    /elements[ \t]*=/{
        gsub(/[{},]/," "); n=split($0,a)
        c=0
        for(i=1;i<=n;i++){
            gsub(/^[ \t]+|[ \t]+$/,"",a[i])
            if (a[i]~/^[0-9]+(\.[0-9]+){3}(\/[0-9]+)?$/ || index(a[i],":"))
                c++
        }
        print c
    }')
    BL_ITEMS=$((BL_ITEMS + ${CNT:-0}))
done <<EOF
$DYNSETS
EOF

# Get named counters
NAMED_CTRS=$($PRINTF '%s\n' "$RULESET" | $AWK '
BEGIN {
    RS = "}"           # elk block sluit met }
    FS = "[[:space:]]+" # velden splitsen op witruimte
}
/^[[:space:]]*counter[[:space:]]+[A-Za-z0-9_]+[[:space:]]+packets/ {
    if ($2 == "packets") next
    for (i = 1; i <= NF; i++) {
        if ($i == "packets" && (i + 1) <= NF) {
            pkt_val = $(i + 1)
            print $2, pkt_val
            break
        }
    }
}')

# Process named counters
while read -r N P;do
    [ -z "$N" ] && continue;
    add_pd "ctr_${N}_pkts" "$P";
done <<EOF
$NAMED_CTRS
EOF

# Inline counters 
INLINE_CTRS=$($PRINTF '%s\n' "$RULESET" | $AWK '
BEGIN { seq = 0 }
{
    if ($0 ~ /counter[[:space:]]+packets[[:space:]]+[0-9]+/) {
        n = split($0, f, /[[:space:]]+/)
        val = 0
        for (i = 1; i <= n; i++)
            if (f[i] == "counter" && i + 2 <= n && f[i + 1] == "packets") {
                val = f[i + 2]; break
            }

        lbl = ""
        if (match($0, /comment[[:space:]]+"[^"]+"/)) {
            c = substr($0, RSTART, RLENGTH)
            sub(/^comment[[:space:]]+"/, "", c)
            sub(/"$/, "", c)
            lbl = c
        } else {
            seq++; lbl = "anon_" seq
        }

        gsub(/[^A-Za-z0-9_]+/, "_", lbl)
        lbl = tolower(lbl)                    # <── nieuwe regel
        isdrop = (index($0, " drop") > 0) ? 1 : 0
        print lbl, val, isdrop
    }
}')

# Process inline counters
while read -r LABEL VALUE ISDROP;do
    add_pd "rule_${LABEL}_pkts" "$VALUE"
    [ "$ISDROP" -eq 1 ] && add_pd "rule_${LABEL}_drops" "$VALUE"
done <<EOF
$INLINE_CTRS
EOF

# Set performance data
PERF_DATA="rules_total=$TOTAL_RULES blacklist_items=$BL_ITEMS $PERF_DATA"

# Check some values
[ -n "$CHAIN_EMPTY" ] && crit "No rules in chain(s): $CHAIN_EMPTY | $PERF_DATA"
[ -n "$TABLE_EMPTY" ] && crit "No rules in table(s): $TABLE_EMPTY | $PERF_DATA"

# Show output
echo "$TOTAL_RULES rules in $TABLE_COUNT table(s), blacklist=$BL_ITEMS | $PERF_DATA"
exit 0