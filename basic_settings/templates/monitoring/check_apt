#!/bin/sh
# Managed by puppet

# Fail helper
die() {
    echo "$*" >&2
    exit 3
}

# Binary checks
APTGET=$(command -v apt-get 2>/dev/null) || die "apt-get not available"
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
DATE=$(command -v date 2>/dev/null) || die "date not available"
FIND=$(command -v find 2>/dev/null) || die "find not available"
STAT=$(command -v stat 2>/dev/null) || die "stat not available"
SORT=$(command -v sort 2>/dev/null) || die "sort not available"
<% if @systemd_enable -%>
SYSTEMCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
<% end -%>

# Defaults
BLACKLIST_FILE="<%= @apt_settings_file %>"
UPDATES_BLACKLISTED=0
UPDATES_TOTAL=0
UPDATES_SECURITY=0
TIMESTAMP_UNKNOWN=0
STAMP_FILE=/var/lib/apt/periodic/update-success-stamp
STAMP_TS=0
LISTS_TS=0
LAST_UPDATE_TIMESTAMP=""
STATE_CODE=0 # 0 OK, 1 WARNING, 2 CRITICAL, 3 UNKNOWN
GRACE=172800 # 48h

# Options
while getopts "c:" opt; do
    case "$opt" in
        c) GRACE=$OPTARG ;;
        *) die "Usage: $0 [-c <seconds>]" ;;
    esac
done

# Run simulation
APT_SIM_CMD="$APTGET -s -o Debug::NoLocking=1 -o APT::Get::Show-Upgraded=true -o Debug::pkgProblemResolver=yes dist-upgrade"
APT_SIM_OUTPUT=$(LC_ALL=C DEBIAN_FRONTEND=noninteractive sh -c "$APT_SIM_CMD" 2>&1)
APT_SIM_RC=$?

# Check for simulation errors
if [ $APT_SIM_RC -ne 0 ]; then    
    # Extract first 10 error/warning lines
    APT_SIM_ERR=$(printf '%s\n' "$APT_SIM_OUTPUT" | "$AWK" '
        BEGIN{c=0}
        /^(E:|Err:|W:)/{gsub(/\r/,""); sub(/^[[:space:]]+/, ""); lines[++c]=$0}
        END{
            if(c==0){print "no apt errors in output"; exit}
            max=(c>10?10:c);
            for(i=1;i<=max;i++){printf "%s%s", (i>1?" ":""), lines[i]}
        }
    ')

    # Show output
    printf 'APT simulation failed (rc=%s). %s\n' "$APT_SIM_RC" "$APT_SIM_ERR"
    exit 3
fi

# Stamp timestamp
if [ -e "$STAMP_FILE" ]; then
    STAMP_TS=$("$STAT" -c %Y "$STAMP_FILE" 2>/dev/null || printf '0')
fi

# Latest mtime in /var/lib/apt/lists (exclude lock and partial)
if [ -d /var/lib/apt/lists ]; then
    LISTS_TS=$("$FIND" /var/lib/apt/lists -type f ! -name lock ! -path '*/partial/*' -printf '%T@\n' 2>/dev/null | "$SORT" -n | "$AWK" 'END { if ($0 ~ /^[0-9.]+$/) printf "%d", $0; else print 0 }')
fi

# Choose newest
case "${STAMP_TS:-0}" in (*[!0-9]*) STAMP_TS=0 ;; esac
case "${LISTS_TS:-0}" in (*[!0-9]*) LISTS_TS=0 ;; esac
if [ "$STAMP_TS" -ge "$LISTS_TS" ]; then
    LAST_UPDATE_TIMESTAMP=$STAMP_TS
else
    LAST_UPDATE_TIMESTAMP=$LISTS_TS
fi

# Compute age
CURRENT_TIME=$("$DATE" +%s)
if [ -n "$LAST_UPDATE_TIMESTAMP" ] && [ "$LAST_UPDATE_TIMESTAMP" -gt 0 ]; then
    LAST_UPDATE_SEC=${LAST_UPDATE_TIMESTAMP%%.*}
    LAST_UPDATE_AGE_SEC=$((CURRENT_TIME - LAST_UPDATE_SEC))
else
    LAST_UPDATE_AGE_SEC=0
fi

# Invalid / skewed timestamp â†’ UNKNOWN
if [ "$LAST_UPDATE_AGE_SEC" -le 0 ] || [ "$LAST_UPDATE_SEC" -gt "$CURRENT_TIME" ]; then
    TIMESTAMP_UNKNOWN=1
fi

# Read blacklist patterns
BLACKLIST_PATTERNS=$("$AWK" '
    /^[[:space:]]*Package-Blacklist/ {inblk=1; next}
    inblk && /^[[:space:]]*}/ {exit}
    inblk && match($0, /"[^"]+"/) { print substr($0, RSTART+1, RLENGTH-2) }
' "$BLACKLIST_FILE" 2>/dev/null || true)

# Parse simulation summary
APT_SIM_SUMMARY=$(printf '%s' "$APT_SIM_OUTPUT" | $AWK '
    /^Inst /{
        total++; pkg=$2; pkgs[pkg]=1;
        if(tolower($0)~/security/){sec++; secpkgs[pkg]=1}
    }
    END{
        for(p in pkgs)    printf "PKG:%s\n",p;
        for(s in secpkgs) printf "SECPKG:%s\n",s;
        printf "TOT:%d\nSEC:%d\n",total,sec;
    }
')

# Set values
UPDATES_TOTAL=$(printf '%s' "$APT_SIM_SUMMARY" | $AWK -F: '/^TOT:/ {print $2}')
UPDATES_SECURITY=$(printf '%s' "$APT_SIM_SUMMARY" | $AWK -F: '/^SEC:/ {print $2}')
PKG_LIST=$(printf '%s' "$APT_SIM_SUMMARY" | $AWK -F: '/^PKG:/ {print $2}')

# Count blacklisted
if [ "$UPDATES_TOTAL" -gt 0 ] && [ -n "$BLACKLIST_PATTERNS" ]; then
    for pkg in $PKG_LIST; do
        for pat in $BLACKLIST_PATTERNS; do
            case "$pkg" in
                $pat) UPDATES_BLACKLISTED=$((UPDATES_BLACKLISTED+1)); break ;;
            esac
        done
    done
fi

# State code
if [ "$TIMESTAMP_UNKNOWN" -eq 0 ]; then
    if [ "$LAST_UPDATE_AGE_SEC" -ge "$GRACE" ] || [ "$UPDATES_SECURITY" -gt 0 ]; then
        STATE_CODE=2
    elif [ "$UPDATES_TOTAL" -gt 0 ]; then
        STATE_CODE=1
    fi
else
    STATE_CODE=3
fi

<% if @systemd_enable -%>
# Timer states
if "$SYSTEMCTL" is-active --quiet apt-daily.timer; then
    TIMER_DAILY_ACTIVE=1
else
    TIMER_DAILY_ACTIVE=0
fi
if "$SYSTEMCTL" is-active --quiet apt-daily-upgrade.timer; then
    TIMER_UPGRADE_ACTIVE=1
else
    TIMER_UPGRADE_ACTIVE=0
fi
if "$SYSTEMCTL" is-active --quiet unattended-upgrades.service; then
    UNATTENDED_ACTIVE=1
else
    UNATTENDED_ACTIVE=0
fi
<% else -%>
TIMER_DAILY_ACTIVE=0
TIMER_UPGRADE_ACTIVE=0
UNATTENDED_ACTIVE=0
<% end -%>

# Message
MSG="APT"
if [ "$TIMESTAMP_UNKNOWN" -eq 0 ]; then
    if [ "$LAST_UPDATE_AGE_SEC" -ge "$GRACE" ]; then
        DAYS=$((LAST_UPDATE_AGE_SEC / 86400))
        MSG="$MSG metadata ${DAYS} days old."
    fi
    MSG="$MSG ${UPDATES_TOTAL} updates (${UPDATES_SECURITY} security)."
else
    MSG="$MSG could not determine last 'apt update' timestamp. ${UPDATES_TOTAL} updates detected (${UPDATES_SECURITY} security)."
fi

# Set messages
[ "$TIMER_DAILY_ACTIVE" -eq 0 ] && MSG="$MSG apt-daily.timer inactive!"
[ "$TIMER_UPGRADE_ACTIVE" -eq 0 ] && MSG="$MSG apt-daily-upgrade.timer inactive!"
[ "$UNATTENDED_ACTIVE" -eq 0 ] && MSG="$MSG unattended-upgrades.service inactive!"

# Reboot
if [ -e /var/run/reboot-required ]; then
    MSG="$MSG Reboot required!"
    [ "$STATE_CODE" -eq 0 ] && STATE_CODE=2
fi

# Blacklisted
if [ "$UPDATES_BLACKLISTED" -gt 0 ]; then
    MSG="$MSG ${UPDATES_BLACKLISTED} blacklisted."
fi

# Security packages
if [ "$UPDATES_SECURITY" -gt 0 ]; then
    SEC_CSV=$(printf '%s' "$APT_SIM_SUMMARY" | $AWK -F: '/^SECPKG:/{pkgs[++n]=$2} END{for(i=1;i<=n;i++){printf "%s%s",(i>1?", ":""),pkgs[i]}}')
    MSG="$MSG Security packages: ${SEC_CSV}."
fi

# Perf data
PERF_DATA="total_updates=${UPDATES_TOTAL};1;;0"
PERF_DATA="$PERF_DATA security_updates=${UPDATES_SECURITY};;1;0"
PERF_DATA="$PERF_DATA blacklisted_updates=${UPDATES_BLACKLISTED};;;0"
PERF_DATA="$PERF_DATA last_update_age=${LAST_UPDATE_AGE_SEC}s;;${GRACE};0"

# Output
printf '%s | %s\n' "$MSG" "$PERF_DATA"
exit "$STATE_CODE"