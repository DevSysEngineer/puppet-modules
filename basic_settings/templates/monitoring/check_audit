#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Binary checks
AUDITCTL=$(command -v auditctl 2>/dev/null) || die "auditctl not available"
AUGENRULES=$(command -v augenrules 2>/dev/null) || die "augenrules not available"
AUSEARCH=$(command -v ausearch 2>/dev/null) || die "ausearch not available"
AUREPORT=$(command -v aureport 2>/dev/null) || die "aureport not available"
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
CUT=$(command -v cut 2>/dev/null) || die "cut not available"
DATE=$(command -v date 2>/dev/null) || die "date not available"
GREP=$(command -v grep 2>/dev/null) || die "grep not available"
SED=$(command -v sed 2>/dev/null) || die "sed not available"
<% if @systemd_enable -%>
SYSTEMDCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
JOURNALCTL=$(command -v journalctl 2>/dev/null) || die "journalctl not available"
<% end -%>
TR=$(command -v tr 2>/dev/null) || die "tr not available"
PS=$(command -v ps 2>/dev/null) || die "ps not available"
UNAME=$(command -v uname 2>/dev/null) || die "uname not available"

crit() {
    printf '%s\n' "$*" >&2
    exit 2
}
trim_file() {
    [ -r "$1" ] || return 1
    val=$($SED -n '1{s/[[:space:]]\+$//;p;q}' "$1" 2>/dev/null | $TR -d '\000\r\n') || return 1
    [ -n "$val" ] || return 1
    printf '%s' "$val"
}

# Defaults values
DMI_DIR="/sys/devices/virtual/dmi/id"
DROPPED_CRIT="1"
HW_SEG=""
MSG="Auditd running"
QUEUE_WARN=""
STATE_CODE=0 # 0 OK, 1 WARNING, 2 CRITICAL, 3 UNKNOWN

# Options
while getopts 'q:d' opt; do
    case "$opt" in
        q) QUEUE_WARN="$OPTARG" ;;
        d) DROPPED_CRIT="$OPTARG" ;;
        *) die "Usage: $0 [-q <int>] [-d <int>]" ;;
    esac
done

# Service running
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "auditd" || crit "Auditd service is not active"
<% else -%>
$PS -C auditd >/dev/null 2>&1 || crit "Auditd service is not active"
<% end -%>

# Audit report (today)
SUM=$($AUREPORT --summary --start today 00:00:00 --end now 2>/dev/null)
get(){ printf "%s" "$SUM" | $AWK -v p="$1" 'index($0,p)==1{print $NF}' | $TR -dc '0-9'; }
ACCT=$(get "Number of changes to accounts, groups, or roles:"); : "${ACCT:=0}"
ANOM=$(get "Number of anomaly events:"); : "${ANOM:=0}"
CFG=$(get "Number of changes in configuration:"); : "${CFG:=0}"
FAIL=$(get "Number of failed syscalls:"); : "${FAIL:=0}"
FAILED_AUTH=$(get "Number of failed authentications:"); : "${FAILED_AUTH:=0}"
KEYS=$(get "Number of keys:"); : "${KEYS:=0}"

# Raise state on notable events
if [ "$ACCT" -gt 0 ] || [ "$ANOM" -gt 0 ] || [ "$CFG" -gt 0 ] || [ "$FAIL" -gt 0 ] || [ "$KEYS" -gt 0 ]; then
    MSG="Strange audit behavior observed"
    STATE_CODE=2
fi

<% if @systemd_enable -%>
# Errors since boot
JLOG=$($JOURNALCTL -b -u auditd -u augenrules --no-pager -o cat 2>/dev/null)
ERR_COMBINED=$(printf "%s\n" "$JLOG" | $AWK '
    {
        line=$0
        l=tolower(line)
        if (l ~ /(error|unknown)/) {
            c++
            prev=last
            last=line
        }
    }
    END{
        if (c==0) { print "0|"; exit }
        if (prev) printf "%d|%s; %s", c, prev, last;
        else      printf "%d|%s",      c, last
    }')
ERROR_COUNT=${ERR_COMBINED%%|*}
ERROR_SNIPPET=${ERR_COMBINED#*|}

# Check if we have any errors
if [ "${ERROR_COUNT:-0}" -gt 0 ]; then
    if [ $STATE_CODE -lt 2 ]; then
        MSG="$MSG, error since boot: ${ERROR_SNIPPET:-unknown}"
    else
        MSG="$MSG; error since boot: ${ERROR_SNIPPET:-unknown}"
    fi
    STATE_CODE=2
fi
<% else -%>
ERROR_COUNT=0
<% end -%>

# Rules count
RULES_COUNT=$($AUDITCTL -l 2>/dev/null | $GREP '^-' | $AWK 'END{print NR+0}')
if [ "$RULES_COUNT" -eq 0 ]; then
    MSG="$MSG, rules 0"
    STATE_CODE=2
else
    MSG="$MSG, rules $RULES_COUNT"
fi

# Queue/backlog stats
AV_STAT=$($AUDITCTL -s 2>/dev/null)
BACKLOG=$(printf "%s" "$AV_STAT" | $SED -n 's/.*backlog=\([0-9]\+\).*/\1/p'); : "${BACKLOG:=0}"
LOST=$(printf "%s" "$AV_STAT" | $SED -n 's/.*lost=\([0-9]\+\).*/\1/p'); : "${LOST:=0}"
BLIMIT=$(printf "%s" "$AV_STAT" | $SED -n 's/.*backlog_limit=\([0-9]\+\).*/\1/p'); : "${BLIMIT:=0}"

# Check result
[ -z "$QUEUE_WARN" ] && QUEUE_WARN=$BLIMIT
if [ "$BACKLOG" -gt "$QUEUE_WARN" ]; then
    MSG="$MSG, backlog $BACKLOG"
    [ $STATE_CODE -lt 1 ] && STATE_CODE=1
fi
if [ "$LOST" -gt "$DROPPED_CRIT" ]; then
    MSG="$MSG, dropped $LOST"
    STATE_CODE=2
fi

# Rules integrity (augenrules --check)
if $AUGENRULES --check >/dev/null 2>&1; then
    MSG="$MSG, augenrules OK"
else
    MSG="$MSG, augenrules diff"
    [ $STATE_CODE -lt 1 ] && STATE_CODE=1
fi

# Boot time
NOW=$($DATE +%s)
BTIME=$($AWK '/btime/ {print $2}' /proc/stat 2>/dev/null)
if [ -n "$BTIME" ]; then
    BOOT_AGE=$(( NOW - BTIME ))
    if [ "$BOOT_AGE" -lt 86400 ]; then
        BOOT_HUMAN=$($DATE -d "@$BTIME" '+%a %Y-%m-%d %H:%M:%S %Z')
        MSG="$MSG, reboot <24h (Boot on $BOOT_HUMAN)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
elif [ -r /proc/uptime ]; then
    UPTIME_SEC=$($CUT -d. -f1 /proc/uptime 2>/dev/null)
    if [ "${UPTIME_SEC:-0}" -lt 86400 ]; then
        BOOT_HUMAN=$($DATE -d "@$(($NOW - UPTIME_SEC))" '+%a %Y-%m-%d %H:%M:%S %Z')
        MSG="$MSG, reboot <24h (Boot on $BOOT_HUMAN)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
fi

<% if @systemd_enable -%>
# Kernel change detection (previous boot)
UPTIME_SEC=$($CUT -d. -f1 /proc/uptime 2>/dev/null)
if [ "${UPTIME_SEC:-0}" -lt 86400 ]; then
    # Try to extract the previous kernel version from the previous boot's journal.
    KERNEL_CURRENT=$($UNAME -r)
    KERNEL_BOOT=$($JOURNALCTL -b -1 -o cat --no-pager 2>/dev/null | $AWK '
        BEGIN{found=0}
        {
            if ($0 ~ /^Linux version[[:space:]]+/) { print $3; found=1; exit }
        }')
    if [ -n "$KERNEL_BOOT" ]; then
        # Previous kernel found; only report if it differs from the current one.
        if [ "$KERNEL_BOOT" != "$KERNEL_CURRENT" ]; then
            MSG="$MSG, kernel change (${KERNEL_BOOT}â†’${KERNEL_CURRENT})"
            [ $STATE_CODE -lt 1 ] && STATE_CODE=1
        fi
    else
        # No previous kernel detected in the journal. We cannot confirm the prior
        # version, but a change may have occurred. Emit a warning without details.
        MSG="$MSG, kernel change? (previous kernel not retrieved)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
fi
<% end -%>

# Check if we have audit keys
if [ "$KEYS" -gt 0 ]; then
    LAST_KEYS=$($AUSEARCH --start 'today 00:00:00' --end now 2>/dev/null | $GREP -o 'key="[^"]\+"' | $SED 's/^key="//; s/"$//' | $AWK 'NF && $0!="(null)"{k[n++]=$0}
        END{
            for(i=n-1;i>=0 && c<5; i--) if(!seen[k[i]]++) list[c++]=k[i];
            for(i=c-1;i>=0;i--) printf "%s%s", list[i], (i? ", ":"")
        }')
    [ -n "$LAST_KEYS" ] && MSG="$MSG, last_keys: $LAST_KEYS"
fi

# Read DMI info if available
if [ -d "$DMI_DIR" ]; then
    # Read DMI information
    CHASSIS_SERIAL=$(trim_file "$DMI_DIR/chassis_serial" 2>/dev/null)
    BOARD_SERIAL=$(trim_file "$DMI_DIR/board_serial" 2>/dev/null)
    PRODUCT_SERIAL=$(trim_file "$DMI_DIR/product_serial" 2>/dev/null)
    BIOS_VENDOR=$(trim_file "$DMI_DIR/bios_vendor" 2>/dev/null)
    BIOS_VERSION=$(trim_file "$DMI_DIR/bios_version" 2>/dev/null)
    BIOS_DATE=$(trim_file "$DMI_DIR/bios_date" 2>/dev/null)

    # Build hardware segment
    [ -n "$CHASSIS_SERIAL" ] && HW_SEG="$HW_SEG, chs:$CHASSIS_SERIAL"
    [ -n "$BOARD_SERIAL" ] && HW_SEG="$HW_SEG, brd:$BOARD_SERIAL"
    [ -n "$PRODUCT_SERIAL" ] && HW_SEG="$HW_SEG, prod:$PRODUCT_SERIAL"

    # BIOS summary
    if [ -n "$BIOS_VENDOR$BIOS_VERSION$BIOS_DATE" ]; then
        BIOS_SUM="$BIOS_VENDOR${BIOS_VERSION:+ }$BIOS_VERSION${BIOS_DATE:+ ($BIOS_DATE)}"
        HW_SEG="$HW_SEG, bios:$BIOS_SUM"
    fi
fi

# Fallback for device-tree platforms (e.g., Raspberry Pi)
if [ -z "$HW_SEG" ] && [ -d /proc/device-tree ]; then
    DT_MODEL=$(trim_file /proc/device-tree/model 2>/dev/null)
    DT_SERIAL=$(trim_file /proc/device-tree/serial-number 2>/dev/null)
    [ -n "$DT_SERIAL" ] && HW_SEG="$HW_SEG, serial:$DT_SERIAL"
    [ -n "$DT_MODEL" ] && HW_SEG="$HW_SEG, model:$DT_MODEL"
fi

# Append hardware summary if present
if [ -n "$HW_SEG" ]; then
    HW_SEG=${HW_SEG#, }
    MSG="$MSG, hw[$HW_SEG]"
fi

# Events per second (last 5 minutes)
EVENT_START=$($DATE -d '5 minute ago' '+%Y-%m-%d %H:%M:%S')
EVENT_REPORT=$($AUREPORT --start "$EVENT_START" --end now --event 2>/dev/null | $AWK 'NR>2{c+=$2}END{print c+0}')
EVENT_RESULT=$($AWK "BEGIN{printf \"%.2f\", (${EVENT_REPORT:-0})/300}")

# Perf data
PERF="acct_changes=${ACCT};;1"
PERF="$PERF anomaly_events=${ANOM};;1"
PERF="$PERF cfg_changes=${CFG};;1"
PERF="$PERF dropped=${LOST};;${DROPPED_CRIT}"
PERF="$PERF errors=${ERROR_COUNT};;1"
PERF="$PERF events_per_sec=${EVENT_RESULT}"
PERF="$PERF failed_auth=${FAILED_AUTH}"
PERF="$PERF failed_syscalls=${FAIL};;1"
PERF="$PERF keys=${KEYS};;1"
PERF="$PERF rules=${RULES_COUNT};;0;0"
PERF="$PERF queue=${BACKLOG};${QUEUE_WARN}"

# Output
printf '%s | %s\n' "${MSG#, }" "$PERF"
exit $STATE_CODE
