#!/bin/sh
# Managed by puppet

die() {
    echo "$*" >&2
    exit 3
}

# Binary checks
AUDITCTL=$(command -v auditctl 2>/dev/null) || die "auditctl not available"
AUGENRULES=$(command -v augenrules 2>/dev/null) || die "augenrules not available"
AUREPORT=$(command -v aureport 2>/dev/null) || die "aureport not available"
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
CUT=$(command -v cut 2>/dev/null) || die "cut not available"
DATE=$(command -v date 2>/dev/null) || die "date not available"
GREP=$(command -v grep 2>/dev/null) || die "grep not available"
SED=$(command -v sed 2>/dev/null) || die "sed not available"
<% if @systemd_enable -%>
SYSTEMDCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
JOURNALCTL=$(command -v journalctl 2>/dev/null) || die "journalctl not available"
<% end -%>
TR=$(command -v tr 2>/dev/null) || die "tr not available"
PS=$(command -v ps 2>/dev/null) || die "ps not available"
UNAME=$(command -v uname 2>/dev/null) || die "uname not available"

crit() {
    printf '%s\n' "$*" >&2
    exit 2
}

# Default values
DROPPED_CRIT="1"
MSG="Auditd running"
STATE_CODE=0 # 0 OK, 1 WARNING, 2 CRITICAL, 3 UNKNOWN
QUEUE_WARN=""

# Options 
while getopts 'q:d' opt; do
    case "$opt" in
        q) QUEUE_WARN="$OPTARG" ;;
        d) DROPPED_CRIT="$OPTARG" ;;
        *) die "Usage: $0 [-q <int>] [-d <int>]" ;;
    esac
done

# Service running
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "auditd" || crit "Auditd service is not active"
<% else -%>
$PS -C efs >/dev/null 2>&1 || crit "Auditd service is not active"
<% end -%>

# Check if we have error since boot
ERROR_COUNT=$($JOURNALCTL -b -u auditd -u augenrules --no-pager 2>/dev/null | $GREP -c 'Error')
if [ "$ERROR_COUNT" -gt 0 ]; then
    MSG="$MSG, but started with error since boot"
    STATE_CODE=2
fi

# Get audit rules
RULES_COUNT=$($AUDITCTL -l 2>/dev/null | $GREP '^-' | $AWK 'END{print NR+0}')
if [ "$RULES_COUNT" -eq 0 ]; then
    MSG="$MSG, rules 0"
    STATE_CODE=2
else
    MSG="$MSG, rules $RULES_COUNT"
fi

# Get backlog / dropped counters
AV_STAT=$($AUDITCTL -s 2>/dev/null)
BACKLOG=$(printf "%s" "$AV_STAT" | $SED -n 's/.*backlog=\([0-9]\+\).*/\1/p'); : "${BACKLOG:=0}"
LOST=$(printf "%s" "$AV_STAT" | $SED -n 's/.*lost=\([0-9]\+\).*/\1/p'); : "${LOST:=0}"
BLIMIT=$(printf "%s" "$AV_STAT" | $SED -n 's/.*backlog_limit=\([0-9]\+\).*/\1/p'); : "${BLIMIT:=0}"

# Check result
[ -z "$QUEUE_WARN" ] && QUEUE_WARN=$BLIMIT
if [ "$BACKLOG" -gt "$QUEUE_WARN" ]; then
    MSG="$MSG, backlog $BACKLOG"
    [ $STATE_CODE -lt 1 ] && STATE_CODE=1
fi
if [ "$LOST" -gt "$DROPPED_CRIT" ]; then
    MSG="$MSG, dropped $LOST"
    STATE_CODE=2 
fi

# Rules‑integriteit (augenrules --check)
if $AUGENRULES --check >/dev/null 2>&1; then
    MSG="$MSG, augenrules OK"
else
    MSG="$MSG, augenrules diff"
    [ $STATE_CODE -lt 1 ] && STATE_CODE=1
fi

# Get audit report
TODAY="$($DATE '+%Y-%m-%d 00:00:00')"
SUM=$($AUREPORT --summary --start "$TODAY" --end now 2>/dev/null)
get(){ printf "%s" "$SUM" | $AWK -v p="$1" 'index($0,p)==1{print $NF}' | $TR -dc '0-9'; }

# Get values from report
CFG=$(get "Number of changes in configuration:"); : "${CFG:=0}"
if [ "$CFG" -gt 0 ]; then
    MSG="$MSG, cfg_changes $CFG"
    STATE_CODE=2
fi

ACCT=$(get "Number of changes to accounts, groups, or roles:"); : "${ACCT:=0}"
if [ "$ACCT" -gt 0 ]; then
    MSG="$MSG, acct_changes $ACCT"
    STATE_CODE=2
fi

FAIL=$(get "Number of failed syscalls:"); : "${FAIL:=0}"
if [ "$FAIL" -gt 0 ]; then
    MSG="$MSG, failed_syscalls $FAIL"
    STATE_CODE=2
fi

ANOM=$(get "Number of anomaly events:"); : "${ANOM:=0}"
if [ "$ANOM" -gt 0 ]; then
    MSG="$MSG, anomaly_events $ANOM"
    STATE_CODE=2
fi

# Performances data
FAILED_AUTH=$(get "Number of failed authentications:"); : "${FAILED_AUTH:=0}"

<% if @systemd_enable -%>
NOW=$($DATE +%s)
BTIME=$(awk '/btime/ {print $2}' /proc/stat 2>/dev/null)
if [ -n "$BTIME" ]; then
    BOOT_AGE=$(( NOW - BTIME ))
    if [ "$BOOT_AGE" -lt 86400 ]; then
        BOOT_HUMAN=$($DATE -d "@$BTIME" '+%a %Y-%m-%d %H:%M:%S %Z')
        MSG="$MSG, reboot <24h (Boot on $BOOT_HUMAN)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
elif [ -r /proc/uptime ]; then
    UPTIME_SEC=$($CUT -d. -f1 /proc/uptime 2>/dev/null)
    if [ "${UPTIME_SEC:-0}" -lt 86400 ]; then
        BOOT_HUMAN=$($DATE -d "@$((NOW - UPTIME_SEC))" '+%a %Y-%m-%d %H:%M:%S %Z')
        MSG="$MSG, reboot <24h (Boot on $BOOT_HUMAN)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
fi

# Kernel change detection (previous boot)
UPTIME_SEC=$($CUT -d. -f1 /proc/uptime 2>/dev/null)
if [ "${UPTIME_SEC:-0}" -lt 86400 ]; then
    # Try to extract the previous kernel version from the previous boot's journal.
    KERNEL_CURRENT=$($UNAME -r)
    KERNEL_BOOT=$($JOURNALCTL -b -1 -o cat --no-pager 2>/dev/null | $AWK 'BEGIN{IGNORECASE=1} /^Linux version[[:space:]]+/ {print $3; exit}')
    if [ -n "$KERNEL_BOOT" ]; then
        # Previous kernel found; only report if it differs from the current one.
        if [ "$KERNEL_BOOT" != "$KERNEL_CURRENT" ]; then
            MSG="$MSG, kernel change (${KERNEL_BOOT}→${KERNEL_CURRENT})"
            [ $STATE_CODE -lt 1 ] && STATE_CODE=1
        fi
    else
        # No previous kernel detected in the journal. We cannot confirm the prior
        # version, but a change may have occurred. Emit a warning without details.
        MSG="$MSG, kernel change? (previous kernel not retrieved)"
        [ $STATE_CODE -lt 1 ] && STATE_CODE=1
    fi
fi
<% end -%>

# Events / sec
EVENT_START=$($DATE -d '5 minute ago' '+%Y-%m-%d %H:%M:%S')
EVENT_REPORT=$($AUREPORT --start "$EVENT_START" --end now --event 2>/dev/null | $AWK 'NR>2{c+=$2}END{print c+0}')
EVENT_RESULT=$($AWK "BEGIN{printf \"%.2f\", (${EVENT_REPORT:-0})/300}")

# Create perf data
PERF="acct_changes=${ACCT};;1"
PERF="$PERF anomaly_events=${ANOM};;1"
PERF="$PERF cfg_changes=${CFG};;1"
PERF="$PERF dropped=${LOST};;${DROPPED_CRIT}"
PERF="$PERF errors=${ERROR_COUNT};;1"
PERF="$PERF events_per_sec=${EVENT_RESULT}"
PERF="$PERF failed_auth=${FAILED_AUTH}"
PERF="$PERF failed_syscalls=${FAIL};;1"
PERF="$PERF rules=${RULES_COUNT};;0;0"
PERF="$PERF queue=${BACKLOG};${QUEUE_WARN}"

# Show output
printf '%s | %s\n' "${MSG#, }" "$PERF"
exit $STATE_CODE
