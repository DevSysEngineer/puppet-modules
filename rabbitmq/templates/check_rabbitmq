#!/bin/sh
# Managed by puppet

die() { 
    echo "$*" >&2 
    exit 3 
}

# Binary checks
AWK=$(command -v awk 2>/dev/null) || die "awk not available"
GREP=$(command -v grep 2>/dev/null) || die "grep not available"
RABBITMQADMIN=$(command -v rabbitmqadmin 2>/dev/null) || die "rabbitmqadmin not available"
RABBITMQCTL=$(command -v rabbitmqctl 2>/dev/null) || die "rabbitmqctl not available"
<% if @systemd_enable -%>
SYSTEMDCTL=$(command -v systemctl 2>/dev/null) || die "systemctl not available"
<% end -%>
PS=$(command -v ps 2>/dev/null) || die "ps not available"

crit() { 
    echo "$*"
    exit 2 
}
warn() { 
    echo "$*"
    exit 1 
}

# Configurable defaults
WARN="25" # warning threshold for queue backlog (can be set via -w)
CRIT="30" # critical threshold for queue backlog (via -c)
RABBITMQADMCONF="<%= @admin_config_path %>" # path to rabbitmqadmin config file (adjust as needed)

# Parse options
while getopts 'w:c:C:' opt; do
  case "$opt" in
    w) WARN="$OPTARG" ;;
    c) CRIT="$OPTARG" ;;
    C) RABBITMQADMCONF="$OPTARG" ;;
    *) die "Usage: $0 [-w <warn_threshold>] [-c <crit_threshold>] [-C <rabbitmqadmin.conf>]" ;;
  esac
done

# Check RabbitMQ service status
<% if @systemd_enable -%>
$SYSTEMDCTL is-active --quiet "rabbitmq-server" || crit "RabbitMQ service is not active"
<% else -%>
$PS -C rabbitmq-server >/dev/null 2>&1 || crit "RabbitMQ service is not active"
<% end -%>

# Retrieve queue metrics
QUEUE_DATA=$($RABBITMQCTL list_queues -q name messages_ready messages_unacknowledged consumers 2>/dev/null) || die "Failed to fetch queue data"

# Set values
CRIT_COUNT=0
CRIT_LIST=""
CRIT_SHOWN=0
LARGEST_ORPHAN_MSG=0
LARGEST_ORPHAN_QUEUE=""
MAX_MSG=0
MAX_MSG_CRIT=0
MAX_MSG_WARN=0
MAX_QUEUE=""
MAX_Q_CRIT=""
MAX_Q_WARN=""
MSG="RabbitMQ running"
NO_CONSUMER_COUNT=0
ORPHAN_LIST=""
ORPHAN_SHOWN=0
QUEUE_COUNT=0
STATE_CODE=0
TOTAL_CONSUMERS=0
TOTAL_MSG=0
TOTAL_READY=0
TOTAL_UNACK=0
WARN_COUNT=0
WARN_LIST=""
WARN_SHOWN=0

append_item() {
  # $1 = current list, $2 = item to append
  if [ -z "$1" ]; then
    printf "%s" "$2"
  else
    printf "%s, %s" "$1" "$2"
  fi
}

# Read tab-separated lines; queue names may contain spaces, so TAB is the only separator.
OLDIFS="$IFS"; IFS='	'  # single literal tab character
while IFS='	' read -r QUEUE_NAME READY UNACK CONSUMERS; do
    # Skip empty and header lines
    [ -z "$QUEUE_NAME" ] && continue
    [ "$QUEUE_NAME" = "name" ] && continue

    # Default missing numeric fields to 0
    READY=${READY:-0}
    UNACK=${UNACK:-0}
    CONSUMERS=${CONSUMERS:-0}

    # Guard: skip any line where numeric fields contain non-digits (robust against unexpected output)
    case "$READY$UNACK$CONSUMERS" in *[!0-9]* ) continue ;; esac

    QUEUE_COUNT=$((QUEUE_COUNT + 1))
    MESSAGES=$((READY + UNACK))
    TOTAL_READY=$((TOTAL_READY + READY))
    TOTAL_UNACK=$((TOTAL_UNACK + UNACK))
    TOTAL_MSG=$((TOTAL_MSG + MESSAGES))
    TOTAL_CONSUMERS=$((TOTAL_CONSUMERS + CONSUMERS))

    # Threshold evaluation (ignore queues without consumers)
    if [ "$CONSUMERS" -gt 0 ]; then
        if [ "$MESSAGES" -ge "$CRIT" ]; then
            CRIT_COUNT=$((CRIT_COUNT + 1))
            if [ "$MESSAGES" -gt "$MAX_MSG_CRIT" ]; then
                MAX_MSG_CRIT=$MESSAGES
                MAX_Q_CRIT="$QUEUE_NAME"
            fi
            ITEM="$QUEUE_NAME=$MESSAGES"
            CRIT_LIST=$(append_item "$CRIT_LIST" "$ITEM")
            CRIT_SHOWN=$((CRIT_SHOWN + 1))
        elif [ "$MESSAGES" -ge "$WARN" ]; then
            WARN_COUNT=$((WARN_COUNT + 1))
            if [ "$MESSAGES" -gt "$MAX_MSG_WARN" ]; then
                MAX_MSG_WARN=$MESSAGES
                MAX_Q_WARN="$QUEUE_NAME"
            fi
            ITEM="$QUEUE_NAME=$MESSAGES"
            WARN_LIST=$(append_item "$WARN_LIST" "$ITEM")
            WARN_SHOWN=$((WARN_SHOWN + 1))
        fi
    fi

    # Queues with messages but no consumers (informational only; no status impact)
    if [ "$CONSUMERS" -eq 0 ] && [ "$MESSAGES" -gt 0 ]; then
        NO_CONSUMER_COUNT=$((NO_CONSUMER_COUNT + 1))
        if [ "$MESSAGES" -gt "$LARGEST_ORPHAN_MSG" ]; then
            LARGEST_ORPHAN_MSG=$MESSAGES
            LARGEST_ORPHAN_QUEUE="$QUEUE_NAME"
        fi
        ITEM="$QUEUE_NAME=$MESSAGES"
        ORPHAN_LIST=$(append_item "$ORPHAN_LIST" "$ITEM")
        ORPHAN_SHOWN=$((ORPHAN_SHOWN + 1))
    fi
done <<EOF
$QUEUE_DATA
EOF
IFS="$OLDIFS"

# Primary status based on thresholds
if [ "$CRIT_COUNT" -gt 0 ]; then
  STATE_CODE=2
  MSG="$MSG, $CRIT_COUNT queue(s) over critical threshold"
  MORE=$((CRIT_COUNT - CRIT_SHOWN))
  [ -n "$CRIT_LIST" ] && MSG="$MSG: $CRIT_LIST"
  [ "$MORE" -gt 0 ] && MSG="$MSG (+$MORE more)"
elif [ "$WARN_COUNT" -gt 0 ]; then
  STATE_CODE=1
  MSG="$MSG, $WARN_COUNT queue(s) over warning threshold"
  MORE=$((WARN_COUNT - WARN_SHOWN))
  [ -n "$WARN_LIST" ] && MSG="$MSG: $WARN_LIST"
  [ "$MORE" -gt 0 ] && MSG="$MSG (+$MORE more)"
fi

# Core totals
MSG="$MSG, queues $QUEUE_COUNT, messages $TOTAL_MSG, consumers $TOTAL_CONSUMERS"

# Append informational note about queues without consumers (no status impact)
if [ "$NO_CONSUMER_COUNT" -gt 0 ]; then
  MORE=$((NO_CONSUMER_COUNT - ORPHAN_SHOWN))
  if [ -n "$ORPHAN_LIST" ]; then
    MSG="$MSG, queues with messages but no consumers: $ORPHAN_LIST"
  else
    MSG="$MSG, queues with messages but no consumers: $LARGEST_ORPHAN_QUEUE=$LARGEST_ORPHAN_MSG"
  fi
  [ "$MORE" -gt 0 ] && MSG="$MSG (+$MORE more)"
fi

# Sum per-queue rates into cluster-level publish/deliver rates.
RATE_DATA=$($RABBITMQADMIN --quiet --format=tsv --config "$RABBITMQADMCONF" list queues message_stats.publish_details.rate message_stats.deliver_get_details.rate 2>/dev/null)

# Sum columns 1 and 2 (tab-separated). If empty, default to 0.00 0.00.
RATE_SUM=$(printf "%s" "$RATE_DATA" | $AWK -F '	' '{pub+=$1; del+=$2} END {if (pub=="") pub=0; if (del=="") del=0; printf "%.2f %.2f", pub, del}')

# Split into positional parameters (POSIX sh trick; no arrays)
set -- $RATE_SUM
PUBLISH_RATE=${1:-0}
DELIVER_RATE=${2:-0}

# Perfdata
PERF="total_messages=${TOTAL_MSG}"
PERF="$PERF messages_ready=${TOTAL_READY}"
PERF="$PERF messages_unack=${TOTAL_UNACK}"
PERF="$PERF max_queue_depth=${MAX_MSG};${WARN};${CRIT};0"
PERF="$PERF publish_rate=${PUBLISH_RATE}"
PERF="$PERF deliver_rate=${DELIVER_RATE}"
PERF="$PERF consumers_total=${TOTAL_CONSUMERS}"
PERF="$PERF queues_total=${QUEUE_COUNT}"

# Show output
printf '%s | %s\n' "${MSG#, }" "$PERF"
exit $STATE_CODE